# 第3课：函数

## 3.1 函数定义

```rust
fn main() {
    println!("Hello from main!");
    another_function();
}

fn another_function() {
    println!("Hello from another function!");
}
```

### 命名规范

- 使用 `snake_case` 命名（小写字母，下划线分隔）
- 函数名应该是动词或动词短语

```rust
fn calculate_sum() {}     // 好
fn CalculateSum() {}      // 不好（驼峰命名）
fn calculatesum() {}      // 不好（难以阅读）
```

## 3.2 参数

```rust
fn main() {
    greet("Alice");
    print_sum(5, 3);
}

fn greet(name: &str) {
    println!("Hello, {}!", name);
}

fn print_sum(a: i32, b: i32) {
    println!("{} + {} = {}", a, b, a + b);
}
```

### 参数必须声明类型

```rust
// 正确
fn add(x: i32, y: i32) {}

// 错误：必须声明类型
// fn add(x, y) {}
```

## 3.3 返回值

```rust
fn main() {
    let result = add(5, 3);
    println!("5 + 3 = {}", result);

    let result2 = five();
    println!("five() = {}", result2);
}

// 使用 -> 声明返回类型
fn add(a: i32, b: i32) -> i32 {
    a + b  // 注意：没有分号，这是表达式
}

fn five() -> i32 {
    5  // 返回 5
}

// 显式使用 return
fn add_with_return(a: i32, b: i32) -> i32 {
    return a + b;  // 有分号
}
```

### 表达式 vs 语句

```rust
fn main() {
    // 语句：执行操作，不返回值
    let x = 5;  // 这是语句

    // 表达式：计算并产生值
    let y = {
        let x = 3;
        x + 1  // 没有分号，是表达式，值为 4
    };
    println!("y = {}", y);  // 输出: y = 4

    // 加分号变成语句，返回 ()
    let z = {
        let x = 3;
        x + 1;  // 有分号，是语句，返回 ()
    };
    // z 的类型是 ()
}
```

## 3.4 提前返回

```rust
fn check_positive(n: i32) -> &'static str {
    if n < 0 {
        return "negative";  // 提前返回
    }

    if n == 0 {
        return "zero";
    }

    "positive"  // 最后的表达式
}
```

## 3.5 不返回的函数 (Never Type)

```rust
fn forever() -> ! {
    loop {
        // 无限循环，永不返回
    }
}

fn crash() -> ! {
    panic!("This function never returns!");
}
```

## 3.6 函数作为参数

```rust
fn main() {
    let result = apply(5, double);
    println!("result = {}", result);  // 10

    let result2 = apply(5, square);
    println!("result2 = {}", result2);  // 25
}

fn double(x: i32) -> i32 {
    x * 2
}

fn square(x: i32) -> i32 {
    x * x
}

// f 是一个函数参数
fn apply(x: i32, f: fn(i32) -> i32) -> i32 {
    f(x)
}
```

## 3.7 闭包 (Closures)

闭包是可以捕获环境变量的匿名函数。

```rust
fn main() {
    // 基本闭包
    let add_one = |x: i32| x + 1;
    println!("{}", add_one(5));  // 6

    // 多参数闭包
    let add = |a, b| a + b;
    println!("{}", add(2, 3));  // 5

    // 带代码块的闭包
    let complex = |x| {
        let y = x * 2;
        y + 1
    };
    println!("{}", complex(3));  // 7

    // 捕获环境变量
    let multiplier = 3;
    let multiply = |x| x * multiplier;
    println!("{}", multiply(5));  // 15
}
```

### 闭包的三种捕获方式

```rust
fn main() {
    let s = String::from("hello");

    // 1. 借用（Fn）
    let print = || println!("{}", s);
    print();
    println!("{}", s);  // s 仍然可用

    // 2. 可变借用（FnMut）
    let mut count = 0;
    let mut increment = || {
        count += 1;
    };
    increment();
    increment();
    println!("count = {}", count);  // 2

    // 3. 获取所有权（FnOnce）
    let s2 = String::from("hello");
    let consume = move || {
        println!("{}", s2);
        drop(s2);
    };
    consume();
    // println!("{}", s2);  // 错误：s2 已被移动
}
```

## 3.8 方法

方法是与特定类型关联的函数。

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 关联函数（无 self，类似静态方法）
    fn new(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }

    // 方法（&self 借用）
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // 方法（&mut self 可变借用）
    fn resize(&mut self, width: u32, height: u32) {
        self.width = width;
        self.height = height;
    }

    // 方法（self 获取所有权）
    fn destroy(self) {
        println!("Destroying rectangle of size {}x{}", self.width, self.height);
        // self 在这里被消耗
    }
}

fn main() {
    let mut rect = Rectangle::new(30, 50);  // 关联函数调用
    println!("Area: {}", rect.area());       // 方法调用

    rect.resize(40, 60);
    println!("New area: {}", rect.area());

    rect.destroy();
    // rect.area();  // 错误：rect 已被消耗
}
```

### self 的三种形式

| 形式 | 含义 | 所有权 |
|------|------|--------|
| `&self` | 不可变借用 | 借用，不消耗 |
| `&mut self` | 可变借用 | 借用，可修改 |
| `self` | 获取所有权 | 消耗，方法调用后不可用 |

## 3.9 泛型函数（预览）

```rust
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];
    for item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let numbers = vec![34, 50, 25, 100, 65];
    let result = largest(&numbers);
    println!("最大数: {}", result);

    let chars = vec!['y', 'm', 'a', 'q'];
    let result = largest(&chars);
    println!("最大字符: {}", result);
}
```

## 3.10 常见模式

### 建造者模式（Builder Pattern）

```rust
struct Config {
    debug: bool,
    verbose: bool,
    output: String,
}

impl Config {
    fn new() -> Self {
        Config {
            debug: false,
            verbose: false,
            output: String::from("output.txt"),
        }
    }

    fn debug(mut self, enable: bool) -> Self {
        self.debug = enable;
        self
    }

    fn verbose(mut self, enable: bool) -> Self {
        self.verbose = enable;
        self
    }

    fn output(mut self, path: &str) -> Self {
        self.output = path.to_string();
        self
    }
}

fn main() {
    let config = Config::new()
        .debug(true)
        .verbose(true)
        .output("result.txt");
}
```

## 知识要点总结

1. 函数使用 `fn` 关键字定义
2. 参数必须声明类型
3. 返回值使用 `->` 声明
4. 函数体最后的表达式（无分号）作为返回值
5. 闭包是可以捕获环境的匿名函数
6. 方法使用 `impl` 块定义，第一个参数是 `self`
7. `self` 有三种形式：`&self`、`&mut self`、`self`
