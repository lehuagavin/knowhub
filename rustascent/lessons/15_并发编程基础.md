# 第15课：并发编程基础

## 15.1 并发 vs 并行

- **并发（Concurrency）**：多个任务交替执行
- **并行（Parallelism）**：多个任务同时执行

Rust 的并发原语同时支持两者。

## 15.2 创建线程

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // 创建新线程
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    // 主线程
    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    // 等待线程完成
    handle.join().unwrap();
}
```

## 15.3 move 闭包

线程闭包默认借用外部变量，使用 `move` 转移所有权。

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    // 错误：v 可能在线程结束前被释放
    // let handle = thread::spawn(|| {
    //     println!("Here's a vector: {:?}", v);
    // });

    // 正确：move 转移所有权
    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    // v 已移动，不能再使用
    // println!("{:?}", v);  // 错误！

    handle.join().unwrap();
}
```

## 15.4 消息传递（Channel）

### 基本用法

```rust
use std::sync::mpsc;  // multiple producer, single consumer
use std::thread;

fn main() {
    // 创建通道
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        // val 已移动，不能再使用
    });

    // 阻塞等待消息
    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```

### 发送多个消息

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    // 将 rx 当作迭代器
    for received in rx {
        println!("Got: {}", received);
    }
}
```

### 多个发送者

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        tx1.send(String::from("from thread 1")).unwrap();
    });

    thread::spawn(move || {
        tx.send(String::from("from thread 2")).unwrap();
    });

    for received in rx {
        println!("Got: {}", received);
    }
}
```

### 同步通道

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    // sync_channel 有固定容量，满了会阻塞发送
    let (tx, rx) = mpsc::sync_channel(1);

    thread::spawn(move || {
        tx.send(1).unwrap();
        println!("sent 1");
        tx.send(2).unwrap();  // 阻塞直到 1 被接收
        println!("sent 2");
    });

    println!("received: {}", rx.recv().unwrap());
    println!("received: {}", rx.recv().unwrap());
}
```

## 15.5 共享状态并发

### Mutex（互斥锁）

```rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        // lock() 返回 MutexGuard，离开作用域自动解锁
        let mut num = m.lock().unwrap();
        *num = 6;
    }  // 自动解锁

    println!("m = {:?}", m);
}
```

### 多线程共享 Mutex

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    // Arc: Atomic Reference Counting
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());  // 10
}
```

### RwLock（读写锁）

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn main() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));

    let data_clone = Arc::clone(&data);

    // 多个读者可以同时读
    let reader = thread::spawn(move || {
        let read_guard = data_clone.read().unwrap();
        println!("Reader sees: {:?}", *read_guard);
    });

    // 写者独占
    {
        let mut write_guard = data.write().unwrap();
        write_guard.push(4);
    }

    reader.join().unwrap();
    println!("Final: {:?}", *data.read().unwrap());
}
```

## 15.6 原子类型

无需锁的线程安全操作。

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

fn main() {
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter.fetch_add(1, Ordering::SeqCst);
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", counter.load(Ordering::SeqCst));  // 10000
}
```

## 15.7 Send 和 Sync trait

Rust 通过 trait 保证线程安全：

- **Send**：可以安全地转移到另一个线程
- **Sync**：可以安全地在线程间共享引用

```rust
// 几乎所有原始类型都是 Send + Sync
// Rc<T> 既不是 Send 也不是 Sync
// RefCell<T> 是 Send 但不是 Sync
// Mutex<T> 是 Send + Sync（如果 T 是 Send）
```

## 15.8 线程局部存储

```rust
use std::cell::RefCell;
use std::thread;

thread_local! {
    static COUNTER: RefCell<u32> = RefCell::new(0);
}

fn main() {
    COUNTER.with(|c| {
        *c.borrow_mut() = 1;
    });

    let handle = thread::spawn(|| {
        COUNTER.with(|c| {
            *c.borrow_mut() = 2;
            println!("Thread: {}", *c.borrow());  // 2
        });
    });

    handle.join().unwrap();

    COUNTER.with(|c| {
        println!("Main: {}", *c.borrow());  // 1
    });
}
```

## 15.9 屏障（Barrier）

让多个线程在某点同步。

```rust
use std::sync::{Arc, Barrier};
use std::thread;

fn main() {
    let barrier = Arc::new(Barrier::new(3));
    let mut handles = vec![];

    for i in 0..3 {
        let barrier = Arc::clone(&barrier);
        let handle = thread::spawn(move || {
            println!("Thread {} before barrier", i);
            barrier.wait();  // 所有线程都到达这里才继续
            println!("Thread {} after barrier", i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

## 15.10 条件变量（Condvar）

```rust
use std::sync::{Arc, Condvar, Mutex};
use std::thread;

fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair2 = Arc::clone(&pair);

    // 等待线程
    thread::spawn(move || {
        let (lock, cvar) = &*pair2;
        let mut started = lock.lock().unwrap();
        while !*started {
            started = cvar.wait(started).unwrap();
        }
        println!("Started!");
    });

    // 通知线程
    thread::sleep(std::time::Duration::from_secs(1));
    let (lock, cvar) = &*pair;
    let mut started = lock.lock().unwrap();
    *started = true;
    cvar.notify_one();

    thread::sleep(std::time::Duration::from_secs(1));
}
```

## 15.11 Once（一次性初始化）

```rust
use std::sync::Once;

static INIT: Once = Once::new();
static mut CONFIG: Option<String> = None;

fn get_config() -> &'static str {
    unsafe {
        INIT.call_once(|| {
            CONFIG = Some(String::from("initialized config"));
        });
        CONFIG.as_ref().unwrap()
    }
}

fn main() {
    println!("{}", get_config());
    println!("{}", get_config());  // 不会重新初始化
}
```

## 15.12 并发模式选择

```
需要线程间通信？
├── 单向数据流 → Channel (mpsc)
├── 共享可变状态
│   ├── 简单计数器 → AtomicXxx
│   ├── 读多写少 → RwLock
│   └── 一般情况 → Mutex
└── 同步点 → Barrier / Condvar
```

## 知识要点总结

1. `thread::spawn` 创建线程，`join` 等待完成
2. `move` 闭包转移所有权到线程
3. **Channel** 实现消息传递，`mpsc` 多生产者单消费者
4. **Mutex** 互斥锁，**RwLock** 读写锁
5. **Arc** 原子引用计数，用于多线程共享
6. **原子类型** 提供无锁的线程安全操作
7. **Send/Sync** trait 保证编译时线程安全
