# 第5课：所有权系统（Rust 核心）

所有权是 Rust 最独特、最重要的特性，它让 Rust 能在没有垃圾回收的情况下保证内存安全。

## 5.1 所有权规则

三条核心规则：

1. Rust 中每个值都有一个 **所有者（owner）**
2. 同一时刻只能有 **一个所有者**
3. 当所有者离开作用域，值会被 **丢弃（drop）**

## 5.2 作用域

```rust
fn main() {
    {                       // s 在这里无效，还未声明
        let s = "hello";    // s 从这里开始有效
        println!("{}", s);  // 可以使用 s
    }                       // 作用域结束，s 不再有效

    // println!("{}", s);   // 错误！s 已超出作用域
}
```

## 5.3 String 类型

```rust
fn main() {
    // 字符串字面量（栈上，不可变）
    let s1 = "hello";

    // String 类型（堆上，可变）
    let mut s2 = String::from("hello");
    s2.push_str(", world!");
    println!("{}", s2);  // hello, world!
}
```

### String 的内存布局

```
栈上（Stack）          堆上（Heap）
+----------+          +---------+
| ptr      | -------> | h e l l |
| len: 5   |          | o       |
| capacity:|          +---------+
| 5        |
+----------+
```

## 5.4 移动（Move）

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // s1 的值移动到 s2

    // println!("{}", s1);  // 错误！s1 已无效
    println!("{}", s2);     // 正确
}
```

### 为什么要移动？

如果允许两个变量指向同一块堆内存：
- 当两个变量都离开作用域时，会尝试释放同一块内存两次
- 这是 "双重释放" 错误，会导致内存损坏

**Rust 的解决方案**：移动后原变量失效

### 移动 vs 浅拷贝 vs 深拷贝

```
浅拷贝（其他语言）：
s1 和 s2 都指向同一块堆内存 → 危险！

移动（Rust）：
s1 的值转移给 s2，s1 失效 → 安全

深拷贝（clone）：
复制堆上的数据，s1 和 s2 各自拥有独立的数据 → 安全但开销大
```

## 5.5 克隆（Clone）

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();  // 深拷贝

    println!("s1 = {}", s1);  // 正确
    println!("s2 = {}", s2);  // 正确
}
```

## 5.6 栈上数据的复制（Copy）

```rust
fn main() {
    let x = 5;
    let y = x;  // 复制，不是移动

    println!("x = {}", x);  // 正确！
    println!("y = {}", y);  // 正确！
}
```

### Copy trait

实现了 `Copy` trait 的类型会自动复制而不是移动：

- 所有整数类型（i32, u64 等）
- 布尔类型（bool）
- 浮点类型（f32, f64）
- 字符类型（char）
- 元组（如果元素都是 Copy 的）：`(i32, i32)` 是 Copy，但 `(i32, String)` 不是

**规则**：如果类型或其任何部分实现了 `Drop` trait，就不能实现 `Copy`

## 5.7 函数与所有权

### 传递所有权

```rust
fn main() {
    let s = String::from("hello");
    takes_ownership(s);     // s 的值移动到函数
    // println!("{}", s);   // 错误！s 已无效

    let x = 5;
    makes_copy(x);          // x 是 Copy，所以被复制
    println!("{}", x);      // 正确！x 仍然有效
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
}  // some_string 离开作用域，drop 被调用，内存被释放

fn makes_copy(some_integer: i32) {
    println!("{}", some_integer);
}  // some_integer 离开作用域，没什么特别的事发生
```

### 返回所有权

```rust
fn main() {
    let s1 = gives_ownership();         // 返回值移动给 s1
    println!("{}", s1);

    let s2 = String::from("hello");
    let s3 = takes_and_gives_back(s2);  // s2 移入，返回值移给 s3
    // println!("{}", s2);              // 错误！s2 已无效
    println!("{}", s3);
}

fn gives_ownership() -> String {
    let s = String::from("hello");
    s  // 返回 s，所有权移出
}

fn takes_and_gives_back(s: String) -> String {
    s  // 返回 s，所有权移出
}
```

## 5.8 引用与借用

每次传递所有权太麻烦？使用引用！

```rust
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);  // 传递引用
    println!("'{}' 的长度是 {}", s1, len);  // s1 仍然有效
}

fn calculate_length(s: &String) -> usize {  // s 是引用
    s.len()
}  // s 离开作用域，但它不拥有所指向的值，所以什么也不会发生
```

### 引用的内存布局

```
栈上                栈上（String）      堆上
+----------+       +----------+       +-------+
| ptr      | ----> | ptr      | ----> | hello |
+----------+       | len: 5   |       +-------+
    &s1            | cap: 5   |
                   +----------+
                       s1
```

### 借用规则

**核心规则**：
- 在任意时刻，只能有 **一个可变引用** 或 **任意数量的不可变引用**
- 引用必须始终有效

```rust
fn main() {
    let s = String::from("hello");

    let r1 = &s;  // 可以
    let r2 = &s;  // 可以：多个不可变引用
    println!("{}, {}", r1, r2);

    // let r3 = &mut s;  // 错误！s 不是 mut
}
```

## 5.9 可变引用

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
    println!("{}", s);  // hello, world
}

fn change(s: &mut String) {
    s.push_str(", world");
}
```

### 可变引用的限制

```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    // let r2 = &mut s;  // 错误！不能同时有两个可变引用
    println!("{}", r1);
}
```

```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &s;      // 不可变借用
    let r2 = &s;      // 可以
    // let r3 = &mut s;  // 错误！已存在不可变借用

    println!("{}, {}", r1, r2);
    // r1 和 r2 在这之后不再使用

    let r3 = &mut s;  // 可以：之前的借用已结束
    println!("{}", r3);
}
```

## 5.10 悬垂引用

Rust 编译器保证引用永远不会悬垂：

```rust
fn main() {
    // let reference = dangle();  // 编译错误
}

fn dangle() -> &String {  // 错误！
    let s = String::from("hello");
    &s  // 返回 s 的引用
}  // s 离开作用域被释放，引用将指向无效内存

// 正确做法：返回所有权
fn no_dangle() -> String {
    let s = String::from("hello");
    s  // 返回 s，所有权移出
}
```

## 5.11 切片（Slice）

切片是对集合中一段连续元素的引用。

### 字符串切片

```rust
fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];   // "hello"
    let world = &s[6..11];  // "world"

    // 简写
    let hello = &s[..5];    // 从开头
    let world = &s[6..];    // 到结尾
    let whole = &s[..];     // 整个字符串

    println!("{} {}", hello, world);
}
```

### 字符串切片类型

```rust
fn main() {
    let s = String::from("hello");

    let slice: &str = &s[0..2];

    // 字符串字面量就是切片
    let literal: &str = "hello world";
}
```

### 数组切片

```rust
fn main() {
    let arr = [1, 2, 3, 4, 5];

    let slice: &[i32] = &arr[1..3];  // [2, 3]
    println!("{:?}", slice);
}
```

### 使用切片的函数

```rust
// 接受 &str 可以同时处理 String 和 &str
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[..i];
        }
    }

    &s[..]
}

fn main() {
    let s = String::from("hello world");
    let word = first_word(&s);     // 传入 &String
    println!("{}", word);

    let literal = "hello world";
    let word = first_word(literal); // 传入 &str
    println!("{}", word);
}
```

## 5.12 所有权可视化

```rust
fn main() {
    let s1 = String::from("hello");  // s1 拥有 "hello"
    //  ^
    //  |
    //  所有者

    let s2 = s1;                     // 所有权转移：s1 → s2
    //  ^
    //  |
    //  新所有者（s1 失效）

    let s3 = s2.clone();             // 克隆：s2 和 s3 各自拥有独立副本
    //  ^
    //  |
    //  拥有独立的 "hello"

    let r1 = &s2;                    // 借用：r1 借用 s2
    //  ^
    //  |
    //  借用者（s2 仍是所有者）

    println!("{}", r1);
}  // s3, s2 被释放（按声明相反顺序）
```

## 知识要点总结

1. **所有权规则**：一个值只有一个所有者，所有者离开作用域时值被释放
2. **移动**：赋值或传参时，堆数据的所有权会转移
3. **Copy**：栈上的简单类型会复制而非移动
4. **Clone**：显式深拷贝堆数据
5. **引用**：借用数据而不获取所有权，用 `&`
6. **可变引用**：允许修改借用的数据，用 `&mut`
7. **借用规则**：要么一个可变引用，要么多个不可变引用
8. **切片**：对集合部分内容的引用
