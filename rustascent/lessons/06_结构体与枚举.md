# 第6课：结构体与枚举

## 6.1 结构体定义

```rust
// 定义结构体
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    // 创建实例
    let user1 = User {
        email: String::from("user@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    println!("用户名: {}", user1.username);
}
```

### 可变结构体

```rust
fn main() {
    // 整个实例必须是可变的
    let mut user1 = User {
        email: String::from("user@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from("new@example.com");
}
```

## 6.2 字段初始化简写

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email,          // 简写：email: email
        username,       // 简写：username: username
        active: true,
        sign_in_count: 1,
    }
}
```

## 6.3 结构体更新语法

```rust
fn main() {
    let user1 = User {
        email: String::from("user1@example.com"),
        username: String::from("user1"),
        active: true,
        sign_in_count: 1,
    };

    // 基于 user1 创建 user2
    let user2 = User {
        email: String::from("user2@example.com"),
        ..user1  // 其余字段从 user1 获取
    };

    // 注意：user1.username 已被移动到 user2
    // println!("{}", user1.username);  // 错误！
    println!("{}", user1.email);        // 可以，这是 user1 自己的
    println!("{}", user1.active);       // 可以，bool 是 Copy
}
```

## 6.4 元组结构体

```rust
// 没有字段名的结构体
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);

    // 访问方式类似元组
    println!("R: {}", black.0);
    println!("G: {}", black.1);
    println!("B: {}", black.2);

    // 解构
    let Color(r, g, b) = black;
    println!("RGB: {}, {}, {}", r, g, b);

    // 注意：Color 和 Point 是不同类型，即使结构相同
}
```

## 6.5 单元结构体

```rust
// 没有任何字段的结构体
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
    // 通常用于实现 trait，但不需要存储数据
}
```

## 6.6 结构体的方法

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 方法：第一个参数是 self
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn perimeter(&self) -> u32 {
        2 * (self.width + self.height)
    }

    // 可变方法
    fn scale(&mut self, factor: u32) {
        self.width *= factor;
        self.height *= factor;
    }

    // 判断方法
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let mut rect = Rectangle { width: 30, height: 50 };

    println!("面积: {}", rect.area());
    println!("周长: {}", rect.perimeter());

    rect.scale(2);
    println!("缩放后: {:?}", rect);

    let rect2 = Rectangle { width: 10, height: 20 };
    println!("能容纳 rect2? {}", rect.can_hold(&rect2));
}
```

## 6.7 关联函数

```rust
impl Rectangle {
    // 关联函数：没有 self 参数
    fn new(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }

    fn square(size: u32) -> Rectangle {
        Rectangle { width: size, height: size }
    }
}

fn main() {
    // 使用 :: 调用关联函数
    let rect = Rectangle::new(30, 50);
    let square = Rectangle::square(20);
}
```

## 6.8 多个 impl 块

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

// 完全合法，可以有多个 impl 块
```

## 6.9 枚举定义

```rust
enum Direction {
    North,
    South,
    East,
    West,
}

fn main() {
    let dir = Direction::North;

    match dir {
        Direction::North => println!("向北"),
        Direction::South => println!("向南"),
        Direction::East => println!("向东"),
        Direction::West => println!("向西"),
    }
}
```

## 6.10 带数据的枚举

```rust
enum Message {
    Quit,                       // 无数据
    Move { x: i32, y: i32 },   // 匿名结构体
    Write(String),              // 包含 String
    ChangeColor(i32, i32, i32), // 包含三个 i32
}

fn main() {
    let msg1 = Message::Quit;
    let msg2 = Message::Move { x: 10, y: 20 };
    let msg3 = Message::Write(String::from("hello"));
    let msg4 = Message::ChangeColor(255, 0, 0);
}
```

### 枚举 vs 多个结构体

```rust
// 使用枚举：一种类型，多种变体
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
}

// 等价于使用多个结构体，但它们是不同类型
struct QuitMessage;
struct MoveMessage { x: i32, y: i32 }
struct WriteMessage(String);

// 枚举的优势：可以轻松定义接受任何 Message 的函数
fn process(msg: Message) { /* ... */ }
```

## 6.11 枚举方法

```rust
impl Message {
    fn call(&self) {
        match self {
            Message::Quit => println!("退出"),
            Message::Move { x, y } => println!("移动到 ({}, {})", x, y),
            Message::Write(text) => println!("写入: {}", text),
            Message::ChangeColor(r, g, b) => {
                println!("改变颜色为 RGB({}, {}, {})", r, g, b)
            }
        }
    }
}

fn main() {
    let msg = Message::Write(String::from("hello"));
    msg.call();
}
```

## 6.12 Option 枚举

Rust 没有 null，使用 `Option<T>` 表示可能不存在的值。

```rust
// 标准库定义
enum Option<T> {
    None,
    Some(T),
}

fn main() {
    let some_number: Option<i32> = Some(5);
    let absent_number: Option<i32> = None;

    // Option 和 T 是不同类型，不能直接使用
    let x: i32 = 5;
    let y: Option<i32> = Some(5);

    // let sum = x + y;  // 错误！类型不匹配

    // 必须处理 None 的情况
    let sum = x + y.unwrap_or(0);  // 如果是 None，使用 0
}
```

### 处理 Option

```rust
fn main() {
    let value: Option<i32> = Some(42);

    // 方式1：match
    match value {
        Some(v) => println!("值是 {}", v),
        None => println!("没有值"),
    }

    // 方式2：if let
    if let Some(v) = value {
        println!("值是 {}", v);
    }

    // 方式3：unwrap（None 时 panic）
    let v = value.unwrap();

    // 方式4：expect（带自定义错误信息的 unwrap）
    let v = value.expect("值不应该为空");

    // 方式5：unwrap_or（提供默认值）
    let v = value.unwrap_or(0);

    // 方式6：unwrap_or_else（延迟计算默认值）
    let v = value.unwrap_or_else(|| {
        println!("计算默认值...");
        0
    });

    // 方式7：map（转换 Some 中的值）
    let doubled: Option<i32> = value.map(|v| v * 2);

    // 方式8：and_then（链式操作）
    let result: Option<i32> = value
        .map(|v| v * 2)
        .and_then(|v| if v > 50 { Some(v) } else { None });
}
```

## 6.13 Result 枚举

用于可能失败的操作。

```rust
// 标准库定义
enum Result<T, E> {
    Ok(T),
    Err(E),
}

use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let file = File::open("hello.txt");

    let file = match file {
        Ok(f) => f,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => {
                match File::create("hello.txt") {
                    Ok(fc) => fc,
                    Err(e) => panic!("创建文件失败: {:?}", e),
                }
            }
            other_error => {
                panic!("打开文件失败: {:?}", other_error)
            }
        },
    };
}
```

## 6.14 derive 属性

```rust
#[derive(Debug)]              // 自动实现 Debug trait
#[derive(Clone)]              // 自动实现 Clone trait
#[derive(Copy, Clone)]        // 自动实现 Copy（需要 Clone）
#[derive(PartialEq, Eq)]      // 自动实现相等比较
#[derive(PartialOrd, Ord)]    // 自动实现排序比较
#[derive(Hash)]               // 自动实现哈希
#[derive(Default)]            // 自动实现默认值

#[derive(Debug, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = p1.clone();

    println!("{:?}", p1);           // Debug
    println!("{}", p1 == p2);       // PartialEq
}
```

## 知识要点总结

1. **结构体**使用 `struct` 定义，包含命名字段
2. **元组结构体**有字段但无字段名
3. **方法**在 `impl` 块中定义，第一个参数是 `self`
4. **关联函数**没有 `self`，用 `::` 调用
5. **枚举**用 `enum` 定义，可以有不同类型的变体
6. **Option<T>** 表示可能不存在的值
7. **Result<T, E>** 表示可能失败的操作
8. **derive** 可以自动实现常用 trait
