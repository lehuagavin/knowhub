# 第19课：测试

## 19.1 编写测试

### 基本测试

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }

    #[test]
    fn test_add_negative() {
        assert_eq!(add(-1, 1), 0);
    }
}
```

### 运行测试

```bash
cargo test                    # 运行所有测试
cargo test test_add           # 运行名称包含 "test_add" 的测试
cargo test -- --nocapture     # 显示 println! 输出
cargo test -- --test-threads=1  # 单线程运行
```

## 19.2 断言宏

### assert!

```rust
#[test]
fn test_assert() {
    assert!(1 + 1 == 2);
    assert!(true, "This message shows on failure");
}
```

### assert_eq! / assert_ne!

```rust
#[test]
fn test_assert_eq() {
    let result = 2 + 2;
    assert_eq!(result, 4, "2 + 2 should equal 4");
}

#[test]
fn test_assert_ne() {
    assert_ne!(1, 2);
}
```

### 调试输出

```rust
#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

#[test]
fn test_point() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 1, y: 2 };
    assert_eq!(p1, p2);  // 需要 Debug + PartialEq
}
```

## 19.3 测试 panic

### should_panic

```rust
pub fn divide(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("Division by zero!");
    }
    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn test_divide_by_zero() {
        divide(1, 0);
    }

    #[test]
    #[should_panic(expected = "Division by zero")]
    fn test_divide_by_zero_with_message() {
        divide(1, 0);
    }
}
```

## 19.4 使用 Result

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn test_with_result() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("math is broken"))
        }
    }

    // 使用 ? 运算符
    #[test]
    fn test_parse() -> Result<(), std::num::ParseIntError> {
        let num: i32 = "42".parse()?;
        assert_eq!(num, 42);
        Ok(())
    }
}
```

## 19.5 忽略测试

```rust
#[test]
#[ignore]
fn expensive_test() {
    // 耗时测试，默认跳过
}

// 运行被忽略的测试
// cargo test -- --ignored
// cargo test -- --include-ignored
```

## 19.6 测试组织

### 单元测试

放在同一文件的 `#[cfg(test)]` 模块中：

```rust
// src/lib.rs
pub fn public_function() -> i32 {
    private_function() + 1
}

fn private_function() -> i32 {
    42
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_public() {
        assert_eq!(public_function(), 43);
    }

    #[test]
    fn test_private() {
        // 可以测试私有函数！
        assert_eq!(private_function(), 42);
    }
}
```

### 集成测试

放在 `tests/` 目录：

```
my_project/
├── src/
│   └── lib.rs
└── tests/
    ├── integration_test.rs
    └── common/
        └── mod.rs
```

```rust
// tests/integration_test.rs
use my_project;  // 作为外部 crate 使用

#[test]
fn test_integration() {
    assert_eq!(my_project::public_function(), 43);
}
```

```rust
// tests/common/mod.rs
pub fn setup() {
    // 公共设置代码
}
```

```rust
// tests/another_test.rs
mod common;

#[test]
fn test_with_setup() {
    common::setup();
    // ...
}
```

## 19.7 文档测试

```rust
/// 计算两个数的和
///
/// # Examples
///
/// ```
/// use my_crate::add;
///
/// assert_eq!(add(2, 3), 5);
/// ```
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

/// # Examples
///
/// ```
/// # use my_crate::divide;  // # 开头的行在文档中隐藏
/// let result = divide(10, 2);
/// assert_eq!(result, 5);
/// ```
///
/// # Panics
///
/// Panics if `b` is zero:
///
/// ```should_panic
/// # use my_crate::divide;
/// divide(10, 0);
/// ```
pub fn divide(a: i32, b: i32) -> i32 {
    a / b
}
```

### 运行文档测试

```bash
cargo test --doc
```

## 19.8 测试私有代码

```rust
mod internal {
    pub(super) fn helper() -> i32 {
        42
    }
}

#[cfg(test)]
mod tests {
    use super::internal;

    #[test]
    fn test_helper() {
        assert_eq!(internal::helper(), 42);
    }
}
```

## 19.9 Mock 和测试替身

### 使用 trait 进行依赖注入

```rust
trait Database {
    fn get(&self, key: &str) -> Option<String>;
}

struct RealDatabase;

impl Database for RealDatabase {
    fn get(&self, key: &str) -> Option<String> {
        // 实际数据库查询
        Some(format!("real_value_for_{}", key))
    }
}

struct MockDatabase {
    data: std::collections::HashMap<String, String>,
}

impl Database for MockDatabase {
    fn get(&self, key: &str) -> Option<String> {
        self.data.get(key).cloned()
    }
}

fn process_data<D: Database>(db: &D, key: &str) -> String {
    match db.get(key) {
        Some(value) => format!("Found: {}", value),
        None => String::from("Not found"),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_process_data() {
        let mut mock = MockDatabase {
            data: std::collections::HashMap::new(),
        };
        mock.data.insert("key1".to_string(), "value1".to_string());

        assert_eq!(process_data(&mock, "key1"), "Found: value1");
        assert_eq!(process_data(&mock, "key2"), "Not found");
    }
}
```

## 19.10 基准测试

### 使用 Criterion

```toml
# Cargo.toml
[dev-dependencies]
criterion = "0.5"

[[bench]]
name = "my_benchmark"
harness = false
```

```rust
// benches/my_benchmark.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use my_crate::fibonacci;

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| {
        b.iter(|| fibonacci(black_box(20)))
    });
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
```

```bash
cargo bench
```

## 19.11 属性测试（Property Testing）

使用 proptest 或 quickcheck：

```toml
[dev-dependencies]
proptest = "1"
```

```rust
use proptest::prelude::*;

fn reverse<T: Clone>(input: &[T]) -> Vec<T> {
    input.iter().rev().cloned().collect()
}

proptest! {
    #[test]
    fn test_reverse_twice(vec in prop::collection::vec(any::<i32>(), 0..100)) {
        let reversed = reverse(&vec);
        let restored = reverse(&reversed);
        prop_assert_eq!(&vec, &restored);
    }
}
```

## 19.12 测试覆盖率

```bash
# 安装 cargo-llvm-cov
cargo install cargo-llvm-cov

# 生成覆盖率报告
cargo llvm-cov

# 生成 HTML 报告
cargo llvm-cov --html
```

## 19.13 测试最佳实践

### 1. 测试命名

```rust
#[test]
fn test_add_positive_numbers() {}

#[test]
fn test_add_returns_error_on_overflow() {}
```

### 2. Arrange-Act-Assert 模式

```rust
#[test]
fn test_user_creation() {
    // Arrange
    let name = "Alice";
    let email = "alice@example.com";

    // Act
    let user = User::new(name, email);

    // Assert
    assert_eq!(user.name(), name);
    assert_eq!(user.email(), email);
}
```

### 3. 一个测试一个断言

```rust
#[test]
fn test_name() {
    let user = User::new("Alice", "alice@example.com");
    assert_eq!(user.name(), "Alice");
}

#[test]
fn test_email() {
    let user = User::new("Alice", "alice@example.com");
    assert_eq!(user.email(), "alice@example.com");
}
```

## 知识要点总结

1. `#[test]` 标记测试函数
2. `#[cfg(test)]` 条件编译测试代码
3. `assert!`、`assert_eq!`、`assert_ne!` 断言
4. `#[should_panic]` 测试期望的 panic
5. 返回 `Result` 可以使用 `?` 运算符
6. 集成测试放在 `tests/` 目录
7. 文档测试在 `/// ` 注释的代码块中
8. 使用 Criterion 进行基准测试
