# 第2课：变量与基本数据类型

## 2.1 变量声明

```rust
fn main() {
    let x = 5;          // 不可变（默认）
    // x = 6;           // 错误！不可变变量不能重新赋值

    let mut y = 5;      // 可变
    y = 6;              // 正确，mut 允许修改
}
```

**为什么默认不可变？**
1. **安全性** - 防止意外修改，编译器在编译期发现错误
2. **并发性** - 不可变数据天然线程安全，无需加锁
3. **可读性** - 看到 `let` 就知道这个值不会变

## 2.2 常量与静态变量

```rust
const MAX_POINTS: u32 = 100_000;
static GREETING: &str = "Hello";
```

| 特性 | `const` | `static` |
|------|---------|----------|
| 本质 | 编译期内联替换（类似宏） | 全局唯一内存地址 |
| 内存 | 无固定地址，每处使用独立拷贝 | 数据段固定地址，程序全程存在 |
| 可变 | 否 | `static mut` 可以，但需 unsafe |
| 类型 | 必须标注 | 必须标注 |

### 本质区别：有没有"身份"

```rust
const C: u32 = 42;
static S: u32 = 42;

fn main() {
    let r1 = &C;
    let r2 = &C;
    // r1 和 r2 可能指向不同临时地址（const 无固定身份）

    let r3 = &S;
    let r4 = &S;
    assert!(std::ptr::eq(r3, r4));  // 一定相同（static 有唯一身份）
}
```

### static mut 的数据竞争问题

`static mut` 是全局可变内存，任意线程随时可读写，编译器**无法检查**访问时序：

```rust
static mut COUNTER: u32 = 0;

// 线程 A                      线程 B
unsafe { COUNTER += 1; }      unsafe { COUNTER += 1; }
//       ↑ 同时写同一内存，结果不可预测（可能只加了 1）
```

这就是**数据竞争**：多线程同时访问同一内存且至少一个在写。因此访问 `static mut` 必须 `unsafe`——你承诺自己保证安全，编译器不帮你检查。

**安全替代**：用 `Mutex` 加锁保证同一时刻只有一个线程访问：

```rust
use std::sync::Mutex;

static COUNTER: Mutex<u32> = Mutex::new(0);

fn increment() {
    *COUNTER.lock().unwrap() += 1;  // 无需 unsafe，锁保证互斥
}
```

### 选择指南

| 场景 | 选择 |
|------|------|
| 数学常量、配置值、魔数 | `const`（零开销，最常用）|
| 需要固定地址（FFI、嵌入式寄存器映射） | `static` |
| 全局可变状态 | `static` + `Mutex`（安全）或 `OnceLock`（单次初始化）|

## 2.3 变量遮蔽 (Shadowing)

```rust
fn main() {
    let x = 5;
    let x = x + 1;      // 遮蔽前一个 x，创建新变量
    let x = x * 2;      // 再次遮蔽
    println!("x = {}", x); // 12

    // 关键：遮蔽可以改变类型（因为本质是新变量）
    let spaces = "   ";        // &str
    let spaces = spaces.len(); // usize

    // mut 不能改变类型（始终是同一个变量）
    let mut y = "hello";
    // y = y.len();   // 错误！类型不匹配
}
```

**典型用途** — 处理链中逐步转换，避免 `input1`, `input2` 这样的命名：

```rust
let input = "  42  ";
let input = input.trim();                 // &str
let input: i32 = input.parse().unwrap();  // i32
```

## 2.4 标量类型

### 整数类型

| 长度 | 有符号 | 无符号 | 范围 |
|------|--------|--------|------|
| 8-bit | i8 | u8 | -128~127 / 0~255 |
| 16-bit | i16 | u16 | -32768~32767 / 0~65535 |
| 32-bit | i32 | u32 | 约 ±21亿 / 0~42亿 |
| 64-bit | i64 | u64 | 约 ±9.2×10¹⁸ |
| 128-bit | i128 | u128 | 约 ±1.7×10³⁸ |
| 架构相关 | isize | usize | 跟随平台指针宽度 |

- 默认整数类型是 **`i32`**（范围够用且缓存友好）
- **`usize`** 用于索引和集合大小，与指针等宽

```rust
let a: i32 = 42;
let b = 1_000_000;    // 下划线分隔提高可读性
let c = 0xff;          // 十六进制
let d = 0b1111;        // 二进制
let e = 1000i64;       // 类型后缀
```

### 整数溢出

```rust
let a: u8 = 255;
// let b = a + 1;  // Debug 模式 panic，Release 模式回绕为 0

// 显式控制溢出行为：
a.wrapping_add(1)     // 总是回绕：0
a.saturating_add(1)   // 饱和到最大值：255
a.overflowing_add(1)  // 返回 (结果, 是否溢出)：(0, true)
a.checked_add(1)      // 溢出返回 None
```

### 浮点类型

```rust
let x = 2.0;       // f64（默认，精度更高，速度相当）
let y: f32 = 3.0;  // f32
```

**精度陷阱**：`0.1 + 0.2 != 0.3`（浮点无法精确表示所有十进制小数），比较应使用容差：`(a - b).abs() < 1e-9`。注意 `f64::EPSILON`（≈2.2e-16）是 1.0 附近的最小精度，不适合作通用容差——值大时太严格，值小时太宽松。

### 布尔与字符

```rust
let t: bool = true;                      // 1 字节
let c: char = '中';                       // 4 字节，Unicode 标量值
```

> `char` 固定 4 字节（存完整 Unicode 码点），字符串用 UTF-8 变长编码（1~4 字节/字符，省空间）。因此 `"你好".len()` = 6（字节数，每个汉字 UTF-8 占 3 字节），`"你好".chars().count()` = 2（字符数）。这也是 Rust 禁止 `s[i]` 索引字符串的原因——字节偏移不等于字符偏移。

## 2.5 复合类型

### 元组 (Tuple)

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
let (x, y, z) = tup;   // 解构
let first = tup.0;      // 索引访问
let unit: () = ();       // 单元类型，表示"没有值"
```

### 数组 (Array)

```rust
let arr = [1, 2, 3, 4, 5];       // [i32; 5]，固定长度，栈分配
let zeros = [0; 10];              // [0, 0, ..., 0]
let first = arr[0];               // 越界会 panic（运行时边界检查）

// 长度是类型的一部分：[i32; 3] 和 [i32; 5] 是不同类型！
```

## 2.6 数组 vs 向量

### 核心区别

| 特性 | 数组 `[T; N]` | 向量 `Vec<T>` |
|------|--------------|---------------|
| 长度 | 编译时固定，是类型的一部分 | 运行时可变 |
| 存储 | 栈上连续存放 | 栈上指针+长度+容量，数据在堆上 |
| 性能 | 零开销，缓存友好 | 间接访问堆，可能触发重新分配 |
| 类型 | `[i32; 3]` ≠ `[i32; 5]` | `Vec<i32>` 不关心长度 |

### 内存布局

```
数组 [i32; 4] — 栈上连续存放，编译器直接知道大小：
    ┌─────┬─────┬─────┬─────┐
    │  1  │  2  │  3  │  4  │   16 字节
    └─────┴─────┴─────┴─────┘

向量 Vec<i32> — 三字段胖结构体（24字节）指向堆内存：
    栈                          堆
    ┌──────────┐                ┌─────┬─────┬─────┬─────┬─────┬─────┐
    │ ptr ─────────────────▶    │  1  │  2  │  3  │  4  │  ?  │  ?  │
    │ len: 4   │                └─────┴─────┴─────┴─────┴─────┴─────┘
    │ cap: 6   │                      已用 4         剩余容量 2
    └──────────┘
```

### 切片 &[T] — 统一接口

切片是对连续内存的**借用视图**，本身不拥有数据。

#### 内存本质：胖指针

普通引用 `&T` 是一个指针（8 字节），切片 `&[T]` 是**胖指针**（16 字节）= 数据指针 + 长度：

```
&[i32] 的内存布局（栈上 16 字节）：
┌──────────┐
│ ptr ──────────▶ 指向某段连续 i32 内存的起始位置
│ len: 3   │      切片覆盖 3 个元素
└──────────┘

它可以指向数组的一部分、Vec 的一部分、或整体——来源无所谓
```

因为携带了长度，运行时可以做边界检查，越界会 panic 而非内存越界。

#### 切片语法

```rust
let arr = [10, 20, 30, 40, 50];

let full  = &arr[..];     // [10, 20, 30, 40, 50] — 全部
let mid   = &arr[1..4];   // [20, 30, 40]         — 左闭右开
let head  = &arr[..3];    // [10, 20, 30]          — 前 3 个
let tail  = &arr[2..];    // [30, 40, 50]          — 从索引 2 到末尾
```

#### 为什么函数参数优先用切片

`&[T]` 同时兼容数组和向量，调用方无需关心数据来源：

```rust
fn sum(data: &[i32]) -> i32 {
    data.iter().sum()
}

fn main() {
    let arr = [1, 2, 3];
    let vec = vec![4, 5, 6];

    sum(&arr);           // &[i32; 3] 自动 Deref 为 &[i32]
    sum(&vec);           // &Vec<i32> 自动 Deref 为 &[i32]
    sum(&arr[1..]);      // 部分切片也是 &[i32]
}
```

自动转换链：`&[T; N]` → `&[T]`（编译器自动 Deref），`&Vec<T>` → `&[T]`（Vec 实现了 `Deref<Target=[T]>`）。

如果写 `fn sum(data: &Vec<i32>)`，调用方就必须传 Vec，数组用不了——**切片是更通用的抽象**。

#### 可变切片

```rust
fn zero_out(data: &mut [i32]) {
    for x in data.iter_mut() {
        *x = 0;
    }
}

let mut arr = [1, 2, 3];
zero_out(&mut arr[1..]);  // arr 变为 [1, 0, 0]
```

#### 字符串切片 &str

`&str` 本质就是 `&[u8]` + "保证是合法 UTF-8" 的约束，同样是胖指针（指针 + 字节长度）：

```rust
let s = String::from("hello");
let slice: &str = &s[0..3];    // "hel"
let literal: &str = "world";   // 字符串字面量本身就是 &str，指向二进制常量区
```

#### String vs &str — 快速对比

| 类型 | `String` | `&str` |
|------|----------|--------|
| 所有权 | 拥有数据（可修改、可增长） | 借用数据（只读视图） |
| 存储 | 栈上指针+长度+容量，数据在堆上 | 栈上胖指针（指针+长度），指向任意 UTF-8 内存 |
| 可变性 | `let mut s = String::new()` 后可增长 | 不可变（切片本身不拥有数据） |
| 典型用途 | 需要修改、拼接、动态构建字符串 | 函数参数、字符串字面量、临时视图 |

```rust
// String — 堆分配，可增长
let mut s = String::from("hello");
s.push_str(", world!");  // OK

// &str — 借用，不可修改大小
let slice: &str = "hello";
// slice.push_str("!");  // 错误！&str 不可变

// 自动转换：&String → &str（函数参数优先用 &str）
fn print(s: &str) { println!("{}", s); }
print(&s);        // &String 自动 Deref 为 &str
print("literal"); // 字面量本身就是 &str
```

> **深入学习**：`String` 涉及所有权、移动、克隆等核心概念，详见 **第5课：所有权系统**。这里只需知道基本区别即可。

#### 切片的关键特性

| 特性 | 说明 |
|------|------|
| 不拥有数据 | 只是借用，受生命周期约束 |
| 零拷贝 | 创建切片不复制数据，只是记录指针和长度 |
| 边界检查 | 运行时检查越界，panic 而非未定义行为 |
| 通用性 | 同一个 `&[T]` 可指向数组、Vec、甚至另一个切片的子区间 |

**选择原则**：编译时定长用数组，运行时变长用向量，函数参数用切片。

## 2.7 类型推断

Rust 在**编译期**推断所有类型（零运行时开销），采用基于约束的**局部类型推断**——编译器从多个线索收集约束，综合判断类型：

```rust
fn main() {
    // 线索1：字面量默认类型
    let x = 5;             // 整数字面量 → i32
    let y = 2.0;           // 浮点字面量 → f64

    // 线索2：上下文前向推断
    let mut v = Vec::new();  // Vec<?>
    v.push(1u8);             // → Vec<u8>

    // 线索3：赋值目标逆向推断
    let parsed: i32 = "42".parse().unwrap();
    //         ^^^^ 从这里反推 parse() 的泛型参数

    // 线索4：综合多个线索
    let mut v = Vec::new();   // Vec<?>
    v.push(1);                // 前向：整数字面量
    let first: u32 = v[0];   // 逆向：u32
    // 综合推断 v: Vec<u32>，字面量 1 也被推断为 u32
}
```

### 推断失败与 turbofish

编译器无法确定唯一类型时需手动标注，用**类型注解**或 **turbofish `::<>`** 语法：

```rust
// let x = "42".parse().unwrap();        // 错误！不知道解析成什么类型
let x: i32 = "42".parse().unwrap();      // 方式1：类型注解
let x = "42".parse::<i32>().unwrap();    // 方式2：turbofish

// let v = (0..10).collect();            // 错误！不知道收集成什么容器
let v: Vec<i32> = (0..10).collect();     // 方式1
let v = (0..10).collect::<Vec<i32>>();   // 方式2
```

### 推断的边界

类型推断是**局部的**，不跨越函数签名——函数参数和返回值类型必须显式标注：

```rust
fn add(a: i32, b: i32) -> i32 { a + b }  // 必须标注

let add = |a, b| a + b;    // 闭包可以推断（局部使用，首次调用时确定类型）
```

## 2.8 类型转换

Rust **不做任何隐式类型转换**（包括 `i32 → i64` 这种"安全"扩展）。这消除了 C/C++ 中大量隐式转换 bug，代价是每次转换都必须显式表达意图。

### 三层转换机制

**`as` — 原始类型强制转换（不检查，你自己负责）：**

```rust
let a: i32 = 300;
let b: u8 = a as u8;     // 截断！300 % 256 = 44
let c: i64 = a as i64;   // 安全扩展
let d = 3.9_f64 as i32;  // 向零截断 → 3
let e = -1i32 as u32;    // 位模式重解释 → 4294967295
```

**`From` / `Into` — 安全转换（编译器保证不丢失信息）：**

```rust
let n: i64 = i64::from(42i32);   // From：保证安全
let n: i64 = 42i32.into();       // Into：From 的反向，自动实现

// 标准库只为不会丢失信息的转换实现了 From：
// u8 → u16/u32/u64/i16/i32/i64  ✓
// i32 → u32                      ✗（负数转不了）
// i64 → i32                      ✗（可能溢出）
```

**`TryFrom` / `TryInto` — 可能失败的转换（返回 Result）：**

```rust
let big: i64 = 10_000_000_000;
let small = u8::try_from(big);   // Err：超出范围
let ok = u8::try_from(42i64);    // Ok(42)
```

### 选择指南

```
确定不丢失信息？  → From / Into（编译器保证安全）
可能丢失信息？    → TryFrom / TryInto（运行时检查）
就是要截断/重释？  → as（你自己负责正确性）
```

## 2.9 数值运算

```rust
let sum = 5 + 10;
let remainder = 43 % 5;
let truncated = -5 / 3;     // -1（向零截断，不是 -2）

// 不同类型不能混合运算
let a: i32 = 5;
let b: i64 = 10;
// let c = a + b;            // 错误！
let c = a as i64 + b;        // 必须显式转换
```

## 知识要点总结

1. 变量默认不可变，`mut` 使其可变
2. `const` 编译时内联，`static` 有固定地址，`let` 可用运行时值
3. 遮蔽创建新变量（可变类型），`mut` 修改同一变量（类型不变）
4. 标量类型：整数（默认 i32）、浮点（默认 f64）、布尔、字符（4 字节 Unicode）
5. **数组 vs 向量**：栈定长 vs 堆变长，切片 `&[T]` 是统一接口
6. **String vs &str**：`String` 拥有堆数据可增长，`&str` 是借用视图，函数参数优先用 `&str`（第5课详细讲解所有权）
7. **类型推断**：编译期从字面量默认类型+上下文+赋值目标综合推断，函数签名必须显式标注
8. **类型转换三层**：`as`（强制）→ `From/Into`（安全）→ `TryFrom/TryInto`（可失败），绝无隐式转换
