# 第18课：宏

## 18.1 宏概述

Rust 有两种宏：
- **声明式宏**（Declarative Macros）：`macro_rules!`
- **过程宏**（Procedural Macros）：derive、属性式、函数式

宏与函数的区别：
- 宏在编译时展开
- 宏可以接受可变数量的参数
- 宏可以生成代码

## 18.2 声明式宏

### 基本语法

```rust
macro_rules! say_hello {
    () => {
        println!("Hello!");
    };
}

fn main() {
    say_hello!();
}
```

### 带参数的宏

```rust
macro_rules! create_function {
    ($func_name:ident) => {
        fn $func_name() {
            println!("You called {:?}()", stringify!($func_name));
        }
    };
}

create_function!(foo);
create_function!(bar);

fn main() {
    foo();  // You called "foo"()
    bar();  // You called "bar"()
}
```

### 指示符（Designators）

| 指示符 | 匹配 |
|--------|------|
| `ident` | 标识符 |
| `expr` | 表达式 |
| `ty` | 类型 |
| `path` | 路径 |
| `stmt` | 语句 |
| `block` | 代码块 |
| `item` | 项（函数、结构体等）|
| `pat` | 模式 |
| `tt` | 单个 token tree |
| `literal` | 字面量 |
| `lifetime` | 生命周期 |

### 多模式匹配

```rust
macro_rules! calculate {
    // 加法
    (add $a:expr, $b:expr) => {
        $a + $b
    };
    // 乘法
    (mul $a:expr, $b:expr) => {
        $a * $b
    };
}

fn main() {
    println!("{}", calculate!(add 1, 2));  // 3
    println!("{}", calculate!(mul 3, 4));  // 12
}
```

### 重复

```rust
macro_rules! vec_of_strings {
    // $()* 表示重复 0 次或多次
    ($($x:expr),*) => {
        {
            let mut v = Vec::new();
            $(
                v.push($x.to_string());
            )*
            v
        }
    };
}

fn main() {
    let v = vec_of_strings!["a", "b", "c"];
    println!("{:?}", v);  // ["a", "b", "c"]
}
```

### 重复语法

- `$(...)*` - 0 次或多次
- `$(...)+` - 1 次或多次
- `$(...)?` - 0 次或 1 次

```rust
macro_rules! print_all {
    // 使用逗号分隔的重复
    ($($x:expr),+ $(,)?) => {  // $(,)? 允许尾随逗号
        $(
            println!("{}", $x);
        )+
    };
}

fn main() {
    print_all!(1, 2, 3);
    print_all!("a", "b",);  // 尾随逗号 OK
}
```

### 实现 vec! 宏

```rust
macro_rules! my_vec {
    () => {
        Vec::new()
    };
    ($elem:expr; $n:expr) => {
        vec![$elem; $n]  // 使用标准库的 vec!
    };
    ($($x:expr),+ $(,)?) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )+
            temp_vec
        }
    };
}

fn main() {
    let v1: Vec<i32> = my_vec![];
    let v2 = my_vec![1, 2, 3];
    let v3 = my_vec![0; 5];

    println!("{:?}", v1);  // []
    println!("{:?}", v2);  // [1, 2, 3]
    println!("{:?}", v3);  // [0, 0, 0, 0, 0]
}
```

## 18.3 过程宏

过程宏更强大，可以操作 Rust 代码的 AST。

### 项目结构

过程宏必须在单独的 crate 中定义：

```toml
# my_macro/Cargo.toml
[package]
name = "my_macro"
version = "0.1.0"

[lib]
proc-macro = true

[dependencies]
syn = "2"
quote = "1"
proc-macro2 = "1"
```

### Derive 宏

```rust
// my_macro/src/lib.rs
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);
    let name = &ast.ident;

    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };

    gen.into()
}
```

使用：

```rust
use my_macro::HelloMacro;

trait HelloMacro {
    fn hello_macro();
}

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();  // Hello, Macro! My name is Pancakes!
}
```

### 属性宏

```rust
// my_macro/src/lib.rs
use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
    let attr_str = attr.to_string();
    let item_str = item.to_string();

    println!("Attribute: {}", attr_str);
    println!("Item: {}", item_str);

    item  // 返回原始代码
}
```

使用：

```rust
#[route(GET, "/")]
fn index() {
    // ...
}
```

### 函数式宏

```rust
// my_macro/src/lib.rs
use proc_macro::TokenStream;

#[proc_macro]
pub fn make_answer(_item: TokenStream) -> TokenStream {
    "fn answer() -> u32 { 42 }".parse().unwrap()
}
```

使用：

```rust
use my_macro::make_answer;

make_answer!();

fn main() {
    println!("{}", answer());  // 42
}
```

## 18.4 常用宏

### println! / print!

```rust
fn main() {
    let name = "Alice";
    let age = 30;

    println!("Hello, {}!", name);
    println!("Name: {name}, Age: {age}");  // Rust 1.58+ 捕获
    println!("{:?}", (1, 2, 3));           // Debug 格式
    println!("{:#?}", vec![1, 2, 3]);      // 美化 Debug
    println!("{:5}", 42);                  // 宽度 5
    println!("{:.2}", 3.14159);            // 2 位小数
    println!("{:b}", 42);                  // 二进制
    println!("{:x}", 255);                 // 十六进制
}
```

### format!

```rust
fn main() {
    let s = format!("Hello, {}!", "world");
    println!("{}", s);
}
```

### dbg!

```rust
fn main() {
    let a = 2;
    let b = dbg!(a * 2) + 1;  // 打印 [src/main.rs:3] a * 2 = 4
    println!("{}", b);        // 5
}
```

### assert! / assert_eq! / assert_ne!

```rust
fn main() {
    assert!(1 + 1 == 2);
    assert_eq!(2 + 2, 4);
    assert_ne!(1, 2);

    // 带自定义消息
    assert!(true, "This should never fail: {}", "custom message");
}
```

### todo! / unimplemented! / unreachable!

```rust
fn work_in_progress() -> i32 {
    todo!("implement this later")
}

fn not_supported() {
    unimplemented!("this feature is not available")
}

fn process(x: i32) {
    match x {
        1 => println!("one"),
        2 => println!("two"),
        _ => unreachable!("x should only be 1 or 2"),
    }
}
```

### cfg!

```rust
fn main() {
    if cfg!(target_os = "linux") {
        println!("Running on Linux");
    }

    if cfg!(debug_assertions) {
        println!("Debug mode");
    }
}
```

### include_str! / include_bytes!

```rust
fn main() {
    // 编译时读取文件
    let readme = include_str!("../README.md");
    let logo = include_bytes!("../logo.png");
}
```

## 18.5 宏卫生性

Rust 宏是"卫生的"，宏内部的标识符不会与外部冲突：

```rust
macro_rules! using_a {
    ($e:expr) => {
        {
            let a = 42;  // 这个 a 不会泄漏
            $e           // $e 中的 a 是外部的
        }
    };
}

fn main() {
    let a = 10;
    let result = using_a!(a + 1);  // 使用外部的 a
    println!("{}", result);        // 11，不是 43
}
```

## 18.6 递归宏

```rust
macro_rules! count {
    () => (0usize);
    ($head:tt $($tail:tt)*) => (1usize + count!($($tail)*));
}

fn main() {
    println!("{}", count!(a b c d e));  // 5
}
```

## 18.7 导出宏

```rust
// 在 crate 根部导出
#[macro_export]
macro_rules! my_macro {
    () => {
        println!("My macro!");
    };
}

// 使用
use my_crate::my_macro;
```

## 18.8 实战：builder 宏

```rust
macro_rules! builder {
    ($name:ident { $($field:ident : $ty:ty),* $(,)? }) => {
        #[derive(Debug, Default)]
        pub struct $name {
            $($field: Option<$ty>,)*
        }

        impl $name {
            pub fn new() -> Self {
                Self::default()
            }

            $(
                pub fn $field(mut self, value: $ty) -> Self {
                    self.$field = Some(value);
                    self
                }
            )*
        }
    };
}

builder!(Person {
    name: String,
    age: u32,
    email: String,
});

fn main() {
    let person = Person::new()
        .name(String::from("Alice"))
        .age(30)
        .email(String::from("alice@example.com"));

    println!("{:?}", person);
}
```

## 知识要点总结

1. **声明式宏**使用 `macro_rules!`，基于模式匹配
2. **过程宏**操作 AST，更强大但更复杂
3. 指示符定义参数类型：`ident`、`expr`、`ty` 等
4. 重复使用 `$(...)*`、`$(...)+`、`$(...)?`
5. 过程宏必须在单独的 crate 中
6. Rust 宏是**卫生的**，避免名称冲突
7. 使用 `#[macro_export]` 导出宏
