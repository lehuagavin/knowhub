# 第13课：迭代器与函数式编程

## 13.1 迭代器基础

迭代器是 Rust 中处理序列数据的核心抽象。

```rust
// Iterator trait 定义
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
    // ... 还有很多默认方法
}
```

### 创建迭代器

```rust
fn main() {
    let v = vec![1, 2, 3];

    // iter()：借用元素 → &T
    let iter1 = v.iter();

    // iter_mut()：可变借用 → &mut T
    let mut v2 = vec![1, 2, 3];
    let iter2 = v2.iter_mut();

    // into_iter()：获取所有权 → T
    let iter3 = v.into_iter();
    // v 不再可用
}
```

### 手动使用 next()

```rust
fn main() {
    let v = vec![10, 20, 30];
    let mut iter = v.iter();

    assert_eq!(iter.next(), Some(&10));
    assert_eq!(iter.next(), Some(&20));
    assert_eq!(iter.next(), Some(&30));
    assert_eq!(iter.next(), None);  // 迭代结束
}
```

## 13.2 迭代器适配器（惰性）

适配器消费一个迭代器，产生另一个迭代器。它们是**惰性**的，不调用终止操作就不会执行。

### map：转换元素

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let doubled: Vec<i32> = v.iter().map(|x| x * 2).collect();
    println!("{:?}", doubled);  // [2, 4, 6, 8, 10]
}
```

### filter：过滤元素

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let evens: Vec<&i32> = v.iter().filter(|x| *x % 2 == 0).collect();
    println!("{:?}", evens);  // [2, 4, 6, 8, 10]
}
```

### filter_map：过滤 + 转换

```rust
fn main() {
    let strings = vec!["42", "abc", "17", "xyz", "99"];

    let numbers: Vec<i32> = strings
        .iter()
        .filter_map(|s| s.parse().ok())
        .collect();

    println!("{:?}", numbers);  // [42, 17, 99]
}
```

### flat_map：展平嵌套

```rust
fn main() {
    let sentences = vec!["hello world", "foo bar baz"];

    let words: Vec<&str> = sentences
        .iter()
        .flat_map(|s| s.split_whitespace())
        .collect();

    println!("{:?}", words);  // ["hello", "world", "foo", "bar", "baz"]
}
```

### enumerate：附加索引

```rust
fn main() {
    let fruits = vec!["apple", "banana", "cherry"];

    for (i, fruit) in fruits.iter().enumerate() {
        println!("{}: {}", i, fruit);
    }
}
```

### zip：配对两个迭代器

```rust
fn main() {
    let names = vec!["Alice", "Bob", "Charlie"];
    let scores = vec![90, 85, 95];

    let results: Vec<_> = names.iter().zip(scores.iter()).collect();
    println!("{:?}", results);  // [("Alice", 90), ("Bob", 85), ("Charlie", 95)]
}
```

### take / skip

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let first_three: Vec<_> = v.iter().take(3).collect();
    println!("{:?}", first_three);  // [1, 2, 3]

    let skip_two: Vec<_> = v.iter().skip(2).collect();
    println!("{:?}", skip_two);  // [3, 4, 5]
}
```

### chain：连接两个迭代器

```rust
fn main() {
    let a = vec![1, 2, 3];
    let b = vec![4, 5, 6];

    let combined: Vec<_> = a.iter().chain(b.iter()).collect();
    println!("{:?}", combined);  // [1, 2, 3, 4, 5, 6]
}
```

### peekable：可以偷看下一个

```rust
fn main() {
    let v = vec![1, 2, 3];
    let mut iter = v.iter().peekable();

    // 偷看但不消费
    assert_eq!(iter.peek(), Some(&&1));
    assert_eq!(iter.peek(), Some(&&1));  // 仍然是 1

    // 消费
    assert_eq!(iter.next(), Some(&1));
    assert_eq!(iter.peek(), Some(&&2));
}
```

## 13.3 消费适配器

消费适配器会消耗迭代器产生最终结果。

### collect：收集为集合

```rust
use std::collections::HashMap;

fn main() {
    // 收集为 Vec
    let v: Vec<i32> = (0..5).collect();

    // 收集为 String
    let s: String = "hello".chars().map(|c| c.to_uppercase().next().unwrap()).collect();

    // 收集为 HashMap
    let map: HashMap<_, _> = vec![("a", 1), ("b", 2)].into_iter().collect();
}
```

### sum / product

```rust
fn main() {
    let sum: i32 = vec![1, 2, 3, 4, 5].iter().sum();
    println!("sum = {}", sum);  // 15

    let product: i32 = vec![1, 2, 3, 4, 5].iter().product();
    println!("product = {}", product);  // 120
}
```

### fold：通用累加

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];

    // fold(初始值, 累加函数)
    let sum = v.iter().fold(0, |acc, x| acc + x);
    println!("sum = {}", sum);  // 15

    // 构建字符串
    let sentence = vec!["hello", "world", "from", "rust"];
    let joined = sentence.iter().fold(String::new(), |mut acc, word| {
        if !acc.is_empty() {
            acc.push(' ');
        }
        acc.push_str(word);
        acc
    });
    println!("{}", joined);  // "hello world from rust"
}
```

### find / position

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let found = v.iter().find(|&&x| x > 3);
    println!("{:?}", found);  // Some(4)

    let pos = v.iter().position(|&x| x == 3);
    println!("{:?}", pos);  // Some(2)
}
```

### any / all

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let has_even = v.iter().any(|x| x % 2 == 0);
    println!("has even: {}", has_even);  // true

    let all_positive = v.iter().all(|x| *x > 0);
    println!("all positive: {}", all_positive);  // true
}
```

### min / max / min_by / max_by

```rust
fn main() {
    let v = vec![3, 1, 4, 1, 5, 9];

    println!("min: {:?}", v.iter().min());  // Some(1)
    println!("max: {:?}", v.iter().max());  // Some(9)

    // 自定义比较
    let words = vec!["hello", "hi", "hey"];
    let longest = words.iter().max_by_key(|w| w.len());
    println!("longest: {:?}", longest);  // Some("hello")
}
```

### count

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    let even_count = v.iter().filter(|x| *x % 2 == 0).count();
    println!("偶数个数: {}", even_count);  // 2
}
```

## 13.4 创建自定义迭代器

```rust
struct Counter {
    count: u32,
    max: u32,
}

impl Counter {
    fn new(max: u32) -> Counter {
        Counter { count: 0, max }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<u32> {
        if self.count < self.max {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

fn main() {
    let counter = Counter::new(5);

    for val in counter {
        print!("{} ", val);
    }
    // 输出: 1 2 3 4 5

    // 自定义迭代器可以使用所有适配器
    let sum: u32 = Counter::new(5)
        .zip(Counter::new(5).skip(1))
        .map(|(a, b)| a * b)
        .filter(|x| x % 2 == 0)
        .sum();

    println!("\nsum = {}", sum);
}
```

## 13.5 实用范式

### 链式处理数据

```rust
fn process_scores(scores: &[(&str, Vec<i32>)]) -> Vec<(String, f64)> {
    scores
        .iter()
        .map(|(name, grades)| {
            let avg = grades.iter().sum::<i32>() as f64 / grades.len() as f64;
            (name.to_string(), avg)
        })
        .filter(|(_, avg)| *avg >= 60.0)
        .collect()
}

fn main() {
    let data = vec![
        ("Alice", vec![85, 90, 78]),
        ("Bob", vec![50, 55, 48]),
        ("Charlie", vec![92, 88, 95]),
    ];

    let passing = process_scores(&data);
    for (name, avg) in &passing {
        println!("{}: {:.1}", name, avg);
    }
}
```

### 分组统计

```rust
use std::collections::HashMap;

fn group_by_first_char(words: &[&str]) -> HashMap<char, Vec<String>> {
    words.iter().fold(HashMap::new(), |mut acc, word| {
        if let Some(ch) = word.chars().next() {
            acc.entry(ch).or_insert_with(Vec::new).push(word.to_string());
        }
        acc
    })
}

fn main() {
    let words = vec!["apple", "avocado", "banana", "blueberry", "cherry"];
    let groups = group_by_first_char(&words);

    for (ch, words) in &groups {
        println!("{}: {:?}", ch, words);
    }
}
```

## 13.6 性能

迭代器在 Rust 中是**零成本抽象**：
- 编译器会将迭代器链优化为等效的手写循环
- 没有运行时开销
- 通常与手动 for 循环性能相同甚至更优（因为编译器能更好地向量化）

## 知识要点总结

1. `iter()` 借用，`iter_mut()` 可变借用，`into_iter()` 获取所有权
2. 适配器是**惰性**的，必须用终止操作消费
3. **map/filter/flat_map** 是最常用的适配器
4. **collect/sum/fold/find** 是最常用的消费器
5. 实现 `Iterator` trait 创建自定义迭代器
6. 迭代器链是**零成本抽象**
