# 第14课：智能指针

## 14.1 智能指针概述

智能指针是行为类似指针的数据结构，同时拥有额外的元数据和能力。

| 类型 | 用途 | 所有权 | 线程安全 |
|------|------|--------|----------|
| `Box<T>` | 堆分配 | 单一所有者 | 否 |
| `Rc<T>` | 引用计数 | 多所有者 | 否 |
| `Arc<T>` | 原子引用计数 | 多所有者 | 是 |
| `RefCell<T>` | 内部可变性 | 单一所有者 | 否 |
| `Mutex<T>` | 互斥锁 | 多所有者 | 是 |
| `RwLock<T>` | 读写锁 | 多所有者 | 是 |

## 14.2 Box<T>：堆分配

```rust
fn main() {
    // 在堆上分配数据
    let b = Box::new(5);
    println!("b = {}", b);

    // 解引用
    let x = *b;
    println!("x = {}", x);
}  // b 离开作用域，堆内存被释放
```

### 使用场景

#### 1. 递归类型

```rust
// 错误：编译器无法确定大小
// enum List {
//     Cons(i32, List),  // 无限嵌套
//     Nil,
// }

// 正确：Box 有固定大小
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```

#### 2. 大数据避免栈溢出

```rust
fn main() {
    // 大数组放在堆上
    let huge_array: Box<[i32; 1_000_000]> = Box::new([0; 1_000_000]);
    println!("array size: {} bytes", std::mem::size_of_val(&huge_array));
}
```

#### 3. trait 对象

```rust
trait Animal {
    fn speak(&self);
}

struct Dog;
impl Animal for Dog {
    fn speak(&self) { println!("Woof!"); }
}

struct Cat;
impl Animal for Cat {
    fn speak(&self) { println!("Meow!"); }
}

fn main() {
    let animals: Vec<Box<dyn Animal>> = vec![
        Box::new(Dog),
        Box::new(Cat),
    ];

    for animal in &animals {
        animal.speak();
    }
}
```

## 14.3 Deref trait

允许自定义解引用行为。

```rust
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}

fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, *y);  // *y 等于 *(y.deref())
}
```

### 解引用强制转换

```rust
fn hello(name: &str) {
    println!("Hello, {}!", name);
}

fn main() {
    let m = MyBox::new(String::from("Rust"));

    // &MyBox<String> → &String → &str
    // Deref 链自动转换
    hello(&m);

    // 等价于
    hello(&(*m)[..]);
}
```

## 14.4 Drop trait

在值离开作用域时执行清理代码。

```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping: {}", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from("first") };
    let d = CustomSmartPointer { data: String::from("second") };
    println!("CustomSmartPointers created.");
}
// 输出：
// CustomSmartPointers created.
// Dropping: second
// Dropping: first
// （按声明的相反顺序 drop）
```

### 提前释放

```rust
fn main() {
    let c = CustomSmartPointer { data: String::from("data") };

    // 不能直接调用 drop 方法
    // c.drop();  // 错误！

    // 使用 std::mem::drop
    drop(c);
    println!("CustomSmartPointer dropped before end of main.");
}
```

## 14.5 Rc<T>：引用计数

允许多个所有者共享数据（单线程）。

```rust
use std::rc::Rc;

fn main() {
    let a = Rc::new(5);
    println!("count after creating a: {}", Rc::strong_count(&a));  // 1

    let b = Rc::clone(&a);  // 增加引用计数
    println!("count after creating b: {}", Rc::strong_count(&a));  // 2

    {
        let c = Rc::clone(&a);
        println!("count after creating c: {}", Rc::strong_count(&a));  // 3
    }

    println!("count after c goes out of scope: {}", Rc::strong_count(&a));  // 2
}
```

### 共享数据结构

```rust
use std::rc::Rc;

enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    //       a = 5 → 10 → Nil
    //             ↗
    //  b = 3 ——————
    //             ↘
    //  c = 4 ——————

    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));

    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```

## 14.6 RefCell<T>：内部可变性

允许在不可变引用后修改数据（运行时借用检查）。

```rust
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(5);

    // 不可变借用
    let borrowed = data.borrow();
    println!("value: {}", *borrowed);
    drop(borrowed);  // 释放借用

    // 可变借用
    *data.borrow_mut() += 1;
    println!("new value: {}", *data.borrow());
}
```

### 借用规则在运行时检查

```rust
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(5);

    let r1 = data.borrow();
    let r2 = data.borrow();
    // let r3 = data.borrow_mut();  // panic! 运行时错误

    println!("{}, {}", *r1, *r2);
}
```

## 14.7 Rc<RefCell<T>>：多所有者可变数据

```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    // 通过 RefCell 修改 leaf 的 children
    leaf.children.borrow_mut().push(Rc::new(Node {
        value: 7,
        children: RefCell::new(vec![]),
    }));

    println!("leaf: {:?}", leaf);
}
```

## 14.8 Weak<T>：弱引用

避免循环引用导致内存泄漏。

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,      // 弱引用
    children: RefCell<Vec<Rc<Node>>>, // 强引用
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    // 设置 leaf 的 parent
    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    // branch 被释放时，leaf.parent.upgrade() 会返回 None
}
```

## 14.9 Cell<T>：Copy 类型的内部可变性

```rust
use std::cell::Cell;

fn main() {
    let x = Cell::new(42);

    let y = x.get();  // 获取副本
    println!("y = {}", y);

    x.set(100);       // 设置新值
    println!("x = {}", x.get());
}
```

## 14.10 选择指南

```
需要堆分配？
└── 是 → 只需单一所有权？
         └── 是 → Box<T>
         └── 否 → 需要跨线程？
                  └── 是 → Arc<T>
                  └── 否 → Rc<T>

需要内部可变性？
└── 是 → 数据是 Copy 类型？
         └── 是 → Cell<T>
         └── 否 → 需要跨线程？
                  └── 是 → Mutex<T> 或 RwLock<T>
                  └── 否 → RefCell<T>

多所有权 + 内部可变性？
└── 单线程 → Rc<RefCell<T>>
└── 多线程 → Arc<Mutex<T>> 或 Arc<RwLock<T>>
```

## 知识要点总结

1. **Box<T>**：堆分配，单一所有者
2. **Rc<T>**：引用计数，多所有者（单线程）
3. **Arc<T>**：原子引用计数，多所有者（多线程）
4. **RefCell<T>**：内部可变性，运行时借用检查
5. **Cell<T>**：Copy 类型的内部可变性
6. **Weak<T>**：弱引用，避免循环引用
7. `Rc<RefCell<T>>` 组合实现多所有者可变数据
