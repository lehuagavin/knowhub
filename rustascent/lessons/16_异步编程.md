# 第16课：异步编程

## 16.1 异步 vs 多线程

| 特性 | 多线程 | 异步 |
|------|--------|------|
| 并发单位 | 操作系统线程 | 任务（Task）|
| 内存开销 | 高（每个线程 ~2MB 栈）| 低（~KB 级）|
| 切换开销 | 高（上下文切换）| 低（协作式）|
| 适用场景 | CPU 密集型 | I/O 密集型 |
| 数量限制 | 通常数千 | 可达数百万 |

## 16.2 async/await 基础

```rust
async fn hello_world() {
    println!("Hello, async world!");
}

#[tokio::main]  // 需要异步运行时
async fn main() {
    // 调用 async 函数返回 Future，需要 await
    hello_world().await;
}
```

### Future trait

```rust
trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}

enum Poll<T> {
    Ready(T),    // 完成
    Pending,     // 还没完成
}
```

## 16.3 异步运行时

Rust 标准库只提供 Future trait，需要外部运行时执行。

### Tokio（最流行）

```toml
# Cargo.toml
[dependencies]
tokio = { version = "1", features = ["full"] }
```

```rust
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    println!("开始");
    sleep(Duration::from_secs(1)).await;
    println!("1秒后");
}
```

### async-std

```toml
[dependencies]
async-std = { version = "1", features = ["attributes"] }
```

```rust
use async_std::task;
use std::time::Duration;

#[async_std::main]
async fn main() {
    task::sleep(Duration::from_secs(1)).await;
}
```

## 16.4 并发执行任务

### tokio::join!（等待所有）

```rust
use tokio::time::{sleep, Duration};

async fn task1() -> i32 {
    sleep(Duration::from_secs(1)).await;
    println!("task1 done");
    1
}

async fn task2() -> i32 {
    sleep(Duration::from_secs(2)).await;
    println!("task2 done");
    2
}

#[tokio::main]
async fn main() {
    // 并发执行，总共约2秒（不是3秒）
    let (r1, r2) = tokio::join!(task1(), task2());
    println!("Results: {}, {}", r1, r2);
}
```

### tokio::select!（等待任一）

```rust
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    tokio::select! {
        _ = sleep(Duration::from_secs(1)) => {
            println!("1秒超时");
        }
        _ = sleep(Duration::from_secs(2)) => {
            println!("2秒超时");
        }
    }
    // 只打印 "1秒超时"，另一个被取消
}
```

### 生成独立任务

```rust
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    // spawn 创建独立任务，返回 JoinHandle
    let handle = tokio::spawn(async {
        sleep(Duration::from_secs(1)).await;
        "task result"
    });

    // 可以继续做其他事情
    println!("Task spawned");

    // 等待任务完成
    let result = handle.await.unwrap();
    println!("Got: {}", result);
}
```

## 16.5 异步 I/O

### 文件读写

```rust
use tokio::fs::File;
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};

#[tokio::main]
async fn main() -> io::Result<()> {
    // 写文件
    let mut file = File::create("hello.txt").await?;
    file.write_all(b"Hello, async!").await?;

    // 读文件
    let mut file = File::open("hello.txt").await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    println!("{}", contents);

    Ok(())
}
```

### TCP 服务器

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};

async fn handle_client(mut socket: TcpStream) {
    let mut buf = [0; 1024];

    loop {
        let n = match socket.read(&mut buf).await {
            Ok(0) => return,  // 连接关闭
            Ok(n) => n,
            Err(_) => return,
        };

        // Echo back
        if socket.write_all(&buf[0..n]).await.is_err() {
            return;
        }
    }
}

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;

    loop {
        let (socket, _) = listener.accept().await?;
        // 为每个连接生成独立任务
        tokio::spawn(async move {
            handle_client(socket).await;
        });
    }
}
```

### HTTP 请求

```toml
[dependencies]
tokio = { version = "1", features = ["full"] }
reqwest = { version = "0.11", features = ["json"] }
```

```rust
use reqwest;

#[tokio::main]
async fn main() -> Result<(), reqwest::Error> {
    let body = reqwest::get("https://httpbin.org/ip")
        .await?
        .text()
        .await?;

    println!("body = {}", body);
    Ok(())
}
```

## 16.6 异步 Channel

```rust
use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    // 创建容量为 32 的通道
    let (tx, mut rx) = mpsc::channel(32);

    tokio::spawn(async move {
        for i in 0..10 {
            tx.send(i).await.unwrap();
        }
    });

    while let Some(value) = rx.recv().await {
        println!("Got: {}", value);
    }
}
```

### 广播通道

```rust
use tokio::sync::broadcast;

#[tokio::main]
async fn main() {
    let (tx, mut rx1) = broadcast::channel(16);
    let mut rx2 = tx.subscribe();

    tokio::spawn(async move {
        while let Ok(value) = rx1.recv().await {
            println!("rx1: {}", value);
        }
    });

    tokio::spawn(async move {
        while let Ok(value) = rx2.recv().await {
            println!("rx2: {}", value);
        }
    });

    tx.send(1).unwrap();
    tx.send(2).unwrap();

    tokio::time::sleep(std::time::Duration::from_millis(100)).await;
}
```

## 16.7 异步互斥锁

```rust
use tokio::sync::Mutex;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let counter = Arc::new(Mutex::new(0));

    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = tokio::spawn(async move {
            let mut num = counter.lock().await;
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.await.unwrap();
    }

    println!("Result: {}", *counter.lock().await);
}
```

## 16.8 超时处理

```rust
use tokio::time::{timeout, Duration};

async fn slow_operation() -> String {
    tokio::time::sleep(Duration::from_secs(10)).await;
    String::from("done")
}

#[tokio::main]
async fn main() {
    match timeout(Duration::from_secs(2), slow_operation()).await {
        Ok(result) => println!("Got: {}", result),
        Err(_) => println!("Operation timed out"),
    }
}
```

## 16.9 Stream（异步迭代器）

```rust
use tokio_stream::{self as stream, StreamExt};

#[tokio::main]
async fn main() {
    let mut stream = stream::iter(vec![1, 2, 3]);

    while let Some(value) = stream.next().await {
        println!("Got: {}", value);
    }
}
```

### 异步 map/filter

```rust
use tokio_stream::{self as stream, StreamExt};

#[tokio::main]
async fn main() {
    let stream = stream::iter(vec![1, 2, 3, 4, 5])
        .filter(|x| *x % 2 == 0)
        .map(|x| x * 2);

    let result: Vec<_> = stream.collect().await;
    println!("{:?}", result);  // [4, 8]
}
```

## 16.10 Pin 和 Unpin

`Pin` 确保数据不会被移动，这对自引用结构（如 Future）很重要。

```rust
use std::pin::Pin;
use std::future::Future;

// 大多数情况下不需要直接使用 Pin
// async/await 会自动处理

// 手动实现 Future 时需要 Pin
fn my_future() -> impl Future<Output = i32> {
    async {
        42
    }
}
```

## 16.11 async 块

```rust
#[tokio::main]
async fn main() {
    // async 块创建匿名 Future
    let future = async {
        println!("Hello from async block");
        42
    };

    let result = future.await;
    println!("Result: {}", result);

    // 带 move 的 async 块
    let name = String::from("Alice");
    let future = async move {
        println!("Hello, {}", name);
    };
    // name 已移动

    future.await;
}
```

## 16.12 最佳实践

### 1. 避免在 async 中阻塞

```rust
// 错误：阻塞整个运行时
async fn bad() {
    std::thread::sleep(std::time::Duration::from_secs(1));
}

// 正确：使用异步版本
async fn good() {
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
}

// 如果必须使用阻塞代码
async fn spawn_blocking_example() {
    let result = tokio::task::spawn_blocking(|| {
        // 阻塞操作在专用线程池执行
        std::thread::sleep(std::time::Duration::from_secs(1));
        42
    }).await.unwrap();

    println!("Result: {}", result);
}
```

### 2. 共享数据使用 Arc

```rust
use std::sync::Arc;
use tokio::sync::Mutex;

#[tokio::main]
async fn main() {
    let shared_data = Arc::new(Mutex::new(vec![]));

    let data = Arc::clone(&shared_data);
    tokio::spawn(async move {
        data.lock().await.push(1);
    }).await.unwrap();

    println!("{:?}", *shared_data.lock().await);
}
```

### 3. 取消安全

```rust
use tokio::select;

#[tokio::main]
async fn main() {
    let mut interval = tokio::time::interval(std::time::Duration::from_secs(1));

    for i in 0..5 {
        select! {
            _ = interval.tick() => {
                println!("tick {}", i);
            }
        }
    }
}
```

## 知识要点总结

1. **async fn** 返回 Future，需要 **await** 驱动执行
2. 需要**异步运行时**（Tokio、async-std）执行 Future
3. **join!** 并发等待所有，**select!** 等待任一
4. **spawn** 创建独立任务
5. 使用异步版本的 I/O 函数（tokio::fs、tokio::net）
6. **Pin** 保证 Future 不被移动
7. 避免在 async 中阻塞，必要时用 **spawn_blocking**
