# 第9课：生命周期

生命周期确保引用在使用期间始终有效，防止悬垂引用。

## 9.1 悬垂引用问题

```rust
fn main() {
    let r;                  // 声明 r
    {
        let x = 5;
        r = &x;             // r 引用 x
    }                       // x 离开作用域，被释放
    // println!("{}", r);   // 错误！r 是悬垂引用
}
```

## 9.2 借用检查器

Rust 编译器有一个借用检查器（borrow checker），比较作用域来判断借用是否有效。

```rust
fn main() {
    let r;                  // ---------+-- 'a
                            //          |
    {                       //          |
        let x = 5;          // -+-- 'b  |
        r = &x;             //  |       |
    }                       // -+       |
                            //          |
    // r 的生命周期 'a 比 x 的生命周期 'b 长
    // 这是不允许的！
}
```

正确的写法：

```rust
fn main() {
    let x = 5;              // ---------+-- 'b
                            //          |
    let r = &x;             // -+-- 'a  |
                            //  |       |
    println!("{}", r);      //  |       |
                            // -+       |
}                           // ---------+
// 'a 完全在 'b 内部，所以 r 始终有效
```

## 9.3 函数中的生命周期

```rust
// 这个函数编译失败
// fn longest(x: &str, y: &str) -> &str {
//     if x.len() > y.len() {
//         x
//     } else {
//         y
//     }
// }
// 错误：缺少生命周期标注

// 正确：使用生命周期标注
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let s1 = String::from("long string");
    let s2 = String::from("xyz");

    let result = longest(&s1, &s2);
    println!("较长的字符串: {}", result);
}
```

## 9.4 生命周期标注语法

```rust
&i32        // 引用
&'a i32     // 带生命周期的引用
&'a mut i32 // 带生命周期的可变引用
```

### 命名约定

- 生命周期参数以 `'` 开头
- 通常使用短名称，如 `'a`、`'b`
- `'static` 是特殊的生命周期

## 9.5 生命周期标注的含义

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str
```

这表示：
- 参数 `x` 和 `y` 的生命周期至少和 `'a` 一样长
- 返回值的生命周期也是 `'a`
- 实际的 `'a` 是 `x` 和 `y` 生命周期的交集（较短的那个）

```rust
fn main() {
    let string1 = String::from("long string");  // ----------+-- 'a
    {                                           //           |
        let string2 = String::from("xyz");      // --+-- 'b  |
        let result = longest(&string1, &string2);//  |       |
        println!("结果: {}", result);           //  |       |
    }                                           // --+       |
    // result 的生命周期是 'b（较短的）          //           |
}                                               // ----------+
```

## 9.6 不同生命周期参数

```rust
// 返回值只依赖于第一个参数
fn first<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
    x
}

// 返回值可以比 y 活得更长
fn main() {
    let x = String::from("hello");
    let result;
    {
        let y = String::from("world");
        result = first(&x, &y);  // 返回 x 的引用
    }
    println!("{}", result);  // 正确！result 的生命周期是 'a
}
```

## 9.7 结构体中的生命周期

```rust
// 结构体包含引用时必须标注生命周期
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();

    let excerpt = ImportantExcerpt {
        part: first_sentence,
    };

    println!("{}", excerpt.part);
}
```

### 结构体生命周期的含义

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}
// 表示：ImportantExcerpt 实例的生命周期不能超过 part 引用的数据
```

## 9.8 方法中的生命周期

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }

    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("注意: {}", announcement);
        self.part
    }
}
```

## 9.9 生命周期省略规则

编译器会自动推断某些情况的生命周期。

### 规则1：输入生命周期

每个引用参数获得独立的生命周期：

```rust
fn foo(x: &i32)              // 等于 fn foo<'a>(x: &'a i32)
fn foo(x: &i32, y: &i32)     // 等于 fn foo<'a, 'b>(x: &'a i32, y: &'b i32)
```

### 规则2：单输入生命周期

如果只有一个输入生命周期，它会被赋给所有输出生命周期：

```rust
fn foo(x: &i32) -> &i32      // 等于 fn foo<'a>(x: &'a i32) -> &'a i32
```

### 规则3：方法的 &self

如果有 `&self` 或 `&mut self`，`self` 的生命周期被赋给所有输出生命周期：

```rust
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        // 返回值的生命周期是 self 的生命周期 'a
        self.part
    }
}
```

## 9.10 静态生命周期

`'static` 生命周期表示引用在整个程序运行期间都有效。

```rust
// 字符串字面量是 'static
let s: &'static str = "Hello, world!";

// 存储在程序二进制中，始终有效
fn main() {
    let static_string: &'static str = "这个字符串持续整个程序";
    println!("{}", static_string);
}
```

### 何时使用 'static

```rust
// 1. 字符串字面量
let s: &'static str = "hello";

// 2. 全局常量
static LANGUAGE: &str = "Rust";

// 3. 错误信息
fn error_message() -> &'static str {
    "发生了错误"
}

// 4. Box::leak（有意泄漏内存）
fn create_static_string(s: String) -> &'static str {
    Box::leak(s.into_boxed_str())
}
```

### 不要滥用 'static

```rust
// 不好：可能不需要 'static
fn bad<T: 'static>(x: T) { }

// 更好：根据实际需求选择
fn better<'a, T: 'a>(x: &'a T) { }
```

## 9.11 同时使用泛型、Trait Bound 和生命周期

```rust
use std::fmt::Display;

fn longest_with_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("公告: {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let s1 = "hello";
    let s2 = "world!";
    let ann = "比较字符串";

    let result = longest_with_announcement(s1, s2, ann);
    println!("较长的: {}", result);
}
```

## 9.12 常见生命周期模式

### 模式1：返回输入的引用

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
    s.split_whitespace().next().unwrap_or("")
}
```

### 模式2：容器持有引用

```rust
struct Container<'a> {
    data: &'a [i32],
}

impl<'a> Container<'a> {
    fn first(&self) -> Option<&i32> {
        self.data.first()
    }
}
```

### 模式3：多个生命周期

```rust
struct Parser<'input, 'config> {
    input: &'input str,
    config: &'config Config,
}
```

### 模式4：生命周期子类型

```rust
fn accept_both<'short, 'long: 'short>(
    short: &'short str,
    long: &'long str,
) -> &'short str {
    if short.len() > 0 {
        short
    } else {
        long  // 'long 可以被当作 'short 使用
    }
}
```

## 9.13 调试生命周期问题

### 技巧1：让编译器告诉你

```rust
// 故意写错类型，编译器会显示推断的生命周期
fn foo(x: &str) -> () {
    // 编译错误会显示 x 的完整类型
    x
}
```

### 技巧2：拆分函数

```rust
// 如果函数生命周期太复杂，考虑拆分
fn complex<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
    // ...
}

// 拆分为
fn part1<'a>(x: &'a str) -> &'a str { /* ... */ }
fn part2<'a>(y: &'a str) { /* ... */ }
```

## 知识要点总结

1. **生命周期**确保引用始终有效
2. **借用检查器**在编译时验证生命周期
3. **生命周期标注**帮助编译器理解引用关系
4. **省略规则**让常见情况不需要显式标注
5. **'static** 表示整个程序运行期间有效
6. 结构体中的引用必须标注生命周期
7. 生命周期是泛型的一种形式
