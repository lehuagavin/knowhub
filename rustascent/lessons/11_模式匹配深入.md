# 第11课：模式匹配深入

## 11.1 模式的分类

### 不可反驳模式（Irrefutable）

总是能匹配成功的模式，用于 `let`、`for`、函数参数。

```rust
fn main() {
    let x = 5;           // x 是不可反驳模式
    let (a, b) = (1, 2); // 元组解构

    for i in 0..5 {       // i 是不可反驳模式
        println!("{}", i);
    }
}
```

### 可反驳模式（Refutable）

可能匹配失败的模式，用于 `if let`、`while let`、`match` 分支。

```rust
fn main() {
    let some_value: Option<i32> = Some(42);

    // if let 使用可反驳模式
    if let Some(x) = some_value {
        println!("值是 {}", x);
    }

    // 错误：let 不能使用可反驳模式
    // let Some(x) = some_value;  // 如果是 None 怎么办？

    // 可以使用 let else
    let Some(x) = some_value else {
        return;
    };
}
```

## 11.2 所有模式语法

### 字面量匹配

```rust
fn main() {
    let x = 1;

    match x {
        1 => println!("一"),
        2 => println!("二"),
        3 => println!("三"),
        _ => println!("其他"),
    }
}
```

### 变量绑定

```rust
fn main() {
    let x = Some(42);

    match x {
        Some(value) => println!("Got: {}", value),  // value 绑定到 42
        None => println!("Nothing"),
    }
}
```

### 多个模式（OR）

```rust
fn main() {
    let x = 2;

    match x {
        1 | 2 => println!("一或二"),
        3 | 4 => println!("三或四"),
        _ => println!("其他"),
    }
}
```

### 范围匹配

```rust
fn main() {
    let x = 5;

    match x {
        1..=5 => println!("1 到 5"),
        6..=10 => println!("6 到 10"),
        _ => println!("其他"),
    }

    let ch = 'c';
    match ch {
        'a'..='j' => println!("前半字母表"),
        'k'..='z' => println!("后半字母表"),
        _ => println!("其他字符"),
    }
}
```

### 结构体解构

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    // 完整解构
    let Point { x, y } = p;
    println!("x = {}, y = {}", x, y);

    // 匹配特定值
    match p {
        Point { x: 0, y } => println!("在 y 轴上, y = {}", y),
        Point { x, y: 0 } => println!("在 x 轴上, x = {}", x),
        Point { x, y } => println!("({}, {})", x, y),
    }

    // 重命名字段
    let Point { x: px, y: py } = p;
    println!("px = {}, py = {}", px, py);
}
```

### 枚举解构

```rust
enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
    Named(String),
}

fn describe_color(color: &Color) {
    match color {
        Color::Rgb(r, g, b) => println!("RGB({}, {}, {})", r, g, b),
        Color::Hsv(h, s, v) => println!("HSV({}, {}, {})", h, s, v),
        Color::Named(name) => println!("Named: {}", name),
    }
}
```

### 嵌套解构

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

fn process(msg: Message) {
    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!("改变颜色为 RGB({}, {}, {})", r, g, b);
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!("改变颜色为 HSV({}, {}, {})", h, s, v);
        }
        _ => {}
    }
}
```

### 忽略值

```rust
fn main() {
    // 用 _ 忽略整个值
    let _ = 42;

    // 用 _ 忽略部分值
    let (first, _, third) = (1, 2, 3);

    // 用 .. 忽略剩余值
    struct Point3D { x: i32, y: i32, z: i32 }
    let point = Point3D { x: 1, y: 2, z: 3 };
    let Point3D { x, .. } = point;
    println!("x = {}", x);

    // 元组中使用 ..
    let numbers = (1, 2, 3, 4, 5);
    let (first, .., last) = numbers;
    println!("first = {}, last = {}", first, last);
}
```

### @ 绑定

```rust
fn main() {
    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello { id: id_variable @ 3..=7 } => {
            println!("Found id in range: {}", id_variable);
        }
        Message::Hello { id: 10..=12 } => {
            println!("Found id in another range");
        }
        Message::Hello { id } => {
            println!("Found some other id: {}", id);
        }
    }
}

enum Message {
    Hello { id: i32 },
}
```

### 匹配守卫

```rust
fn main() {
    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 => println!("{} 是偶数", x),
        Some(x) => println!("{} 是奇数", x),
        None => println!("没有值"),
    }

    // 守卫与 OR 模式组合
    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y => println!("yes"),  // 守卫应用于所有 OR 分支
        _ => println!("no"),
    }
}
```

## 11.3 实用模式技巧

### 匹配引用

```rust
fn main() {
    let reference = &4;

    // 方式1：在模式中解引用
    match reference {
        &val => println!("Got value: {}", val),
    }

    // 方式2：先解引用
    match *reference {
        val => println!("Got value: {}", val),
    }

    // 方式3：ref 绑定
    let value = 5;
    match value {
        ref r => println!("Got reference to value: {}", r),
    }
}
```

### 可变引用绑定

```rust
fn main() {
    let mut value = 5;

    match value {
        ref mut m => {
            *m += 10;
            println!("New value: {}", m);
        }
    }
}
```

## 知识要点总结

1. **不可反驳模式**用于 let/for/函数参数
2. **可反驳模式**用于 if let/while let/match
3. 支持字面量、变量绑定、多模式、范围匹配
4. 结构体和枚举支持**嵌套解构**
5. `_` 忽略单个值，`..` 忽略剩余值
6. `@` 绑定在匹配的同时创建变量
7. 匹配守卫添加额外条件
