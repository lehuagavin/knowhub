# 第10课：常用集合

## 10.1 Vector

### 创建 Vector

```rust
fn main() {
    // 方式1：空 vector
    let v1: Vec<i32> = Vec::new();

    // 方式2：使用 vec! 宏
    let v2 = vec![1, 2, 3];

    // 方式3：指定容量
    let v3: Vec<i32> = Vec::with_capacity(10);
}
```

### 添加元素

```rust
fn main() {
    let mut v = Vec::new();

    v.push(1);
    v.push(2);
    v.push(3);

    println!("{:?}", v);  // [1, 2, 3]

    // 在指定位置插入
    v.insert(1, 10);  // [1, 10, 2, 3]

    // 追加另一个 vector
    let mut other = vec![4, 5];
    v.append(&mut other);  // other 变为空
}
```

### 访问元素

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];

    // 方式1：索引（越界会 panic）
    let third = v[2];
    println!("第三个元素: {}", third);

    // 方式2：get（返回 Option）
    match v.get(2) {
        Some(value) => println!("第三个元素: {}", value),
        None => println!("没有第三个元素"),
    }

    // 越界访问
    // let does_not_exist = v[100];  // panic!
    let does_not_exist = v.get(100);  // None
}
```

### 遍历

```rust
fn main() {
    let v = vec![1, 2, 3];

    // 不可变遍历
    for i in &v {
        println!("{}", i);
    }

    // 可变遍历
    let mut v = vec![1, 2, 3];
    for i in &mut v {
        *i *= 2;
    }
    println!("{:?}", v);  // [2, 4, 6]

    // 带索引遍历
    for (i, value) in v.iter().enumerate() {
        println!("索引 {} 的值是 {}", i, value);
    }
}
```

### 删除元素

```rust
fn main() {
    let mut v = vec![1, 2, 3, 4, 5];

    // 删除最后一个
    let last = v.pop();  // Some(5)

    // 删除指定位置
    let removed = v.remove(1);  // 删除索引1的元素，返回2

    // 保留满足条件的元素
    v.retain(|&x| x > 2);  // [3, 4]

    // 清空
    v.clear();
}
```

### 常用方法

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];

    println!("长度: {}", v.len());
    println!("是否为空: {}", v.is_empty());
    println!("是否包含3: {}", v.contains(&3));
    println!("第一个元素: {:?}", v.first());
    println!("最后一个元素: {:?}", v.last());

    // 切片
    let slice = &v[1..3];  // [2, 3]

    // 排序
    let mut v = vec![3, 1, 4, 1, 5, 9];
    v.sort();
    println!("{:?}", v);  // [1, 1, 3, 4, 5, 9]

    // 去重（需要先排序）
    v.dedup();
    println!("{:?}", v);  // [1, 3, 4, 5, 9]
}
```

## 10.2 String

### 创建 String

```rust
fn main() {
    // 方式1：空字符串
    let s1 = String::new();

    // 方式2：从字面量
    let s2 = String::from("hello");
    let s3 = "hello".to_string();

    // 方式3：从字符迭代器
    let s4: String = ['h', 'e', 'l', 'l', 'o'].iter().collect();
}
```

### 修改字符串

```rust
fn main() {
    let mut s = String::from("hello");

    // 追加字符串
    s.push_str(", world");

    // 追加字符
    s.push('!');

    println!("{}", s);  // hello, world!

    // 插入
    s.insert(0, 'H');
    s.insert_str(1, "ello ");

    // 替换
    let s = String::from("hello hello");
    let new_s = s.replace("hello", "world");  // "world world"
    let new_s = s.replacen("hello", "world", 1);  // "world hello"
}
```

### 拼接字符串

```rust
fn main() {
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");

    // 方式1：+ 运算符（s1 被移动）
    let s3 = s1 + &s2;
    // println!("{}", s1);  // 错误！s1 已被移动

    // 方式2：format! 宏（不移动任何值）
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = format!("{}{}", s1, s2);
    println!("{}", s1);  // 仍然有效

    // 方式3：push_str
    let mut s = String::from("Hello, ");
    s.push_str(&s2);
}
```

### 索引和切片

```rust
fn main() {
    let s = String::from("hello");

    // 错误：不能直接索引
    // let h = s[0];

    // 原因：UTF-8 中一个字符可能占多个字节
    let chinese = String::from("你好");
    println!("字节长度: {}", chinese.len());       // 6
    println!("字符数量: {}", chinese.chars().count());  // 2

    // 字符串切片（必须在字符边界）
    let hello = &s[0..5];  // "hello"

    // 错误：不在字符边界
    // let bad = &chinese[0..1];  // panic!

    // 正确
    let good = &chinese[0..3];  // "你"
}
```

### 遍历字符串

```rust
fn main() {
    let s = String::from("你好 Rust");

    // 按字符遍历
    for c in s.chars() {
        println!("{}", c);
    }

    // 按字节遍历
    for b in s.bytes() {
        println!("{}", b);
    }

    // 按字素簇遍历（需要外部 crate）
}
```

### 常用方法

```rust
fn main() {
    let s = String::from("  Hello, World!  ");

    // 去除空白
    let trimmed = s.trim();  // "Hello, World!"

    // 大小写转换
    let upper = s.to_uppercase();
    let lower = s.to_lowercase();

    // 分割
    let parts: Vec<&str> = "a,b,c".split(',').collect();

    // 包含检查
    let contains = s.contains("World");
    let starts = s.starts_with("  Hello");
    let ends = s.ends_with("!  ");

    // 查找
    let pos = s.find("World");  // Some(9)
}
```

## 10.3 HashMap

### 创建 HashMap

```rust
use std::collections::HashMap;

fn main() {
    // 方式1：空 HashMap
    let mut scores: HashMap<String, i32> = HashMap::new();

    // 方式2：从迭代器
    let teams = vec![String::from("Blue"), String::from("Red")];
    let initial_scores = vec![10, 50];
    let scores: HashMap<_, _> = teams.into_iter()
        .zip(initial_scores.into_iter())
        .collect();

    // 方式3：使用 from
    let scores = HashMap::from([
        (String::from("Blue"), 10),
        (String::from("Red"), 50),
    ]);
}
```

### 插入和访问

```rust
use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();

    // 插入
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Red"), 50);

    // 访问
    let team_name = String::from("Blue");
    let score = scores.get(&team_name);  // Option<&i32>

    match score {
        Some(s) => println!("Blue 队得分: {}", s),
        None => println!("没有找到 Blue 队"),
    }

    // copied() 获取值的副本
    let score: Option<i32> = scores.get(&team_name).copied();

    // 默认值
    let score = scores.get(&team_name).copied().unwrap_or(0);
}
```

### 遍历

```rust
use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Red"), 50);

    // 遍历键值对
    for (key, value) in &scores {
        println!("{}: {}", key, value);
    }

    // 只遍历键
    for key in scores.keys() {
        println!("{}", key);
    }

    // 只遍历值
    for value in scores.values() {
        println!("{}", value);
    }
}
```

### 更新值

```rust
use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();

    // 覆盖
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Blue"), 25);  // 覆盖

    // 只在键不存在时插入
    scores.entry(String::from("Yellow")).or_insert(50);
    scores.entry(String::from("Blue")).or_insert(50);  // 不会覆盖

    println!("{:?}", scores);  // {"Yellow": 50, "Blue": 25}

    // 基于旧值更新
    let text = "hello world wonderful world";
    let mut word_count = HashMap::new();

    for word in text.split_whitespace() {
        let count = word_count.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{:?}", word_count);
    // {"hello": 1, "world": 2, "wonderful": 1}
}
```

### 所有权

```rust
use std::collections::HashMap;

fn main() {
    let field_name = String::from("color");
    let field_value = String::from("blue");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);

    // field_name 和 field_value 已被移动
    // println!("{}", field_name);  // 错误！

    // 使用引用避免移动
    let field_name = String::from("size");
    let field_value = String::from("large");
    let mut map: HashMap<&String, &String> = HashMap::new();
    map.insert(&field_name, &field_value);

    println!("{}", field_name);  // 有效
}
```

## 10.4 HashSet

```rust
use std::collections::HashSet;

fn main() {
    // 创建
    let mut set: HashSet<i32> = HashSet::new();

    // 插入
    set.insert(1);
    set.insert(2);
    set.insert(3);
    set.insert(1);  // 重复，不会插入

    println!("{:?}", set);  // {1, 2, 3}

    // 检查包含
    println!("包含 1? {}", set.contains(&1));  // true

    // 删除
    set.remove(&1);

    // 集合运算
    let set1: HashSet<_> = [1, 2, 3].into_iter().collect();
    let set2: HashSet<_> = [2, 3, 4].into_iter().collect();

    // 并集
    let union: HashSet<_> = set1.union(&set2).collect();

    // 交集
    let intersection: HashSet<_> = set1.intersection(&set2).collect();

    // 差集
    let difference: HashSet<_> = set1.difference(&set2).collect();

    // 对称差集
    let symmetric: HashSet<_> = set1.symmetric_difference(&set2).collect();
}
```

## 10.5 VecDeque（双端队列）

```rust
use std::collections::VecDeque;

fn main() {
    let mut deque = VecDeque::new();

    // 后端操作
    deque.push_back(1);
    deque.push_back(2);

    // 前端操作
    deque.push_front(0);

    println!("{:?}", deque);  // [0, 1, 2]

    // 弹出
    let front = deque.pop_front();  // Some(0)
    let back = deque.pop_back();    // Some(2)
}
```

## 10.6 BinaryHeap（优先队列）

```rust
use std::collections::BinaryHeap;

fn main() {
    let mut heap = BinaryHeap::new();

    // 插入
    heap.push(3);
    heap.push(1);
    heap.push(4);
    heap.push(1);
    heap.push(5);

    // 查看最大值（不移除）
    println!("最大值: {:?}", heap.peek());  // Some(5)

    // 弹出最大值
    while let Some(max) = heap.pop() {
        println!("{}", max);  // 5, 4, 3, 1, 1
    }
}
```

## 知识要点总结

1. **Vec<T>** 是动态数组，元素在堆上连续存储
2. **String** 是 UTF-8 编码的可变字符串
3. **HashMap<K, V>** 存储键值对，需要引入 std::collections
4. **HashSet<T>** 存储唯一值的集合
5. 这些集合的元素在离开作用域时会被自动清理
6. 使用引用访问集合元素时要注意借用规则
