# 第7课：错误处理

Rust 将错误分为两类：
- **可恢复错误**：如文件未找到，使用 `Result<T, E>`
- **不可恢复错误**：如数组越界，使用 `panic!`

## 7.1 panic! 宏

```rust
fn main() {
    // 显式 panic
    panic!("程序崩溃!");

    // 这行不会执行
    println!("这不会打印");
}
```

### panic 的行为

```rust
fn main() {
    let v = vec![1, 2, 3];

    // 数组越界会 panic
    v[99];  // thread 'main' panicked at '...'
}
```

### 设置 panic 行为

在 `Cargo.toml` 中：

```toml
[profile.release]
panic = 'abort'  # 直接终止，不展开栈
```

### 查看 panic 回溯

```bash
RUST_BACKTRACE=1 cargo run
```

## 7.2 Result 类型

```rust
use std::fs::File;

fn main() {
    let file_result: Result<File, std::io::Error> = File::open("hello.txt");

    let file = match file_result {
        Ok(f) => f,
        Err(e) => {
            println!("打开文件失败: {}", e);
            return;
        }
    };
}
```

## 7.3 匹配不同错误

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let file = File::open("hello.txt");

    let file = match file {
        Ok(f) => f,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => {
                // 文件不存在，尝试创建
                match File::create("hello.txt") {
                    Ok(fc) => fc,
                    Err(e) => panic!("创建文件失败: {:?}", e),
                }
            }
            ErrorKind::PermissionDenied => {
                panic!("没有权限: {:?}", error)
            }
            other => panic!("其他错误: {:?}", other),
        },
    };
}
```

### 使用闭包简化

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("创建文件失败: {:?}", error);
            })
        } else {
            panic!("打开文件失败: {:?}", error);
        }
    });
}
```

## 7.4 unwrap 和 expect

```rust
use std::fs::File;

fn main() {
    // unwrap: Ok 时返回值，Err 时 panic
    let file = File::open("hello.txt").unwrap();

    // expect: 类似 unwrap，但可以指定错误信息
    let file = File::open("hello.txt")
        .expect("无法打开 hello.txt");
}
```

### 什么时候用 unwrap/expect？

- **原型开发阶段**：快速验证逻辑
- **测试代码**：失败即表示测试失败
- **确定不会出错**：逻辑上保证不会是 Err

```rust
// 这种情况确定不会出错
let num: i32 = "42".parse().expect("硬编码的字符串应该能解析");
```

## 7.5 错误传播

### 手动传播

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let file = File::open("hello.txt");

    let mut file = match file {
        Ok(f) => f,
        Err(e) => return Err(e),  // 返回错误
    };

    let mut username = String::new();

    match file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
```

### ? 运算符

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut file = File::open("hello.txt")?;  // 出错则提前返回
    let mut username = String::new();
    file.read_to_string(&mut username)?;
    Ok(username)
}
```

### ? 的工作原理

`?` 运算符对 `Result` 做了以下操作：
- 如果是 `Ok(value)`，提取 `value` 继续执行
- 如果是 `Err(e)`，调用 `From::from(e)` 转换错误类型，然后返回

```rust
// 这段代码
let file = File::open("hello.txt")?;

// 等价于
let file = match File::open("hello.txt") {
    Ok(f) => f,
    Err(e) => return Err(From::from(e)),
};
```

### 链式调用

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();
    File::open("hello.txt")?.read_to_string(&mut username)?;
    Ok(username)
}

// 更简洁：使用标准库函数
fn read_username_from_file_v2() -> Result<String, io::Error> {
    std::fs::read_to_string("hello.txt")
}
```

## 7.6 ? 用于 Option

```rust
fn first_char(text: &str) -> Option<char> {
    text.lines().next()?.chars().next()
}

fn main() {
    let text = "hello\nworld";
    println!("{:?}", first_char(text));  // Some('h')

    let empty = "";
    println!("{:?}", first_char(empty)); // None
}
```

## 7.7 main 函数返回 Result

```rust
use std::fs::File;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let file = File::open("hello.txt")?;
    Ok(())
}
```

## 7.8 自定义错误类型

```rust
use std::fmt;

// 定义错误枚举
#[derive(Debug)]
enum AppError {
    IoError(std::io::Error),
    ParseError(std::num::ParseIntError),
    Custom(String),
}

// 实现 Display trait
impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::IoError(e) => write!(f, "IO 错误: {}", e),
            AppError::ParseError(e) => write!(f, "解析错误: {}", e),
            AppError::Custom(msg) => write!(f, "错误: {}", msg),
        }
    }
}

// 实现 Error trait
impl std::error::Error for AppError {}

// 实现 From trait 进行自动转换
impl From<std::io::Error> for AppError {
    fn from(err: std::io::Error) -> AppError {
        AppError::IoError(err)
    }
}

impl From<std::num::ParseIntError> for AppError {
    fn from(err: std::num::ParseIntError) -> AppError {
        AppError::ParseError(err)
    }
}

// 使用自定义错误
fn process_file(path: &str) -> Result<i32, AppError> {
    let content = std::fs::read_to_string(path)?;  // 自动转换为 AppError
    let number: i32 = content.trim().parse()?;     // 自动转换为 AppError
    Ok(number)
}
```

## 7.9 常用错误处理模式

### 模式1：提供默认值

```rust
fn main() {
    let config = std::fs::read_to_string("config.txt")
        .unwrap_or_else(|_| String::from("default config"));

    let number = "42abc".parse::<i32>().unwrap_or(0);
}
```

### 模式2：转换错误

```rust
fn main() {
    let result: Result<i32, String> = "42".parse()
        .map_err(|e| format!("解析失败: {}", e));
}
```

### 模式3：组合多个 Result

```rust
fn process() -> Result<i32, Box<dyn std::error::Error>> {
    let a = "10".parse::<i32>()?;
    let b = "20".parse::<i32>()?;
    Ok(a + b)
}
```

### 模式4：ok() 和 err()

```rust
fn main() {
    let result: Result<i32, &str> = Ok(42);

    // 转换为 Option
    let ok_value: Option<i32> = result.ok();     // Some(42)
    let err_value: Option<&str> = result.err();  // None
}
```

### 模式5：and_then 链式处理

```rust
fn parse_and_double(s: &str) -> Result<i32, std::num::ParseIntError> {
    s.parse::<i32>().and_then(|n| Ok(n * 2))
}

fn main() {
    println!("{:?}", parse_and_double("21"));  // Ok(42)
    println!("{:?}", parse_and_double("abc")); // Err(...)
}
```

## 7.10 何时 panic vs Result

### 使用 panic! 的情况

1. **不可恢复的错误**：程序状态已损坏
2. **示例和原型代码**
3. **测试代码**
4. **编译器无法判断的不可能情况**

```rust
// 逻辑上保证不会出错
let home: std::net::IpAddr = "127.0.0.1"
    .parse()
    .expect("硬编码的 IP 地址应该有效");
```

### 使用 Result 的情况

1. **预期可能失败**：文件操作、网络请求
2. **需要让调用者决定如何处理**
3. **库代码**：让用户决定错误处理策略

## 7.11 assert! 宏

```rust
fn main() {
    let x = 5;

    // 断言条件为真
    assert!(x == 5);

    // 带消息的断言
    assert!(x > 0, "x 必须是正数，实际值: {}", x);

    // 断言相等
    assert_eq!(x, 5);
    assert_eq!(x, 5, "x 应该等于 5");

    // 断言不相等
    assert_ne!(x, 0);
}
```

### debug_assert!

```rust
fn main() {
    let x = expensive_computation();

    // 只在 debug 构建时检查
    debug_assert!(x > 0, "x 必须是正数");

    // release 构建时被编译器移除
}
```

## 知识要点总结

1. **panic!** 用于不可恢复的错误
2. **Result<T, E>** 用于可恢复的错误
3. **?** 运算符简化错误传播
4. **unwrap/expect** 快速提取值，出错时 panic
5. **自定义错误**应实现 `Display` 和 `Error` trait
6. **From trait** 实现自动错误类型转换
7. 库代码优先返回 **Result**，让调用者决定如何处理
