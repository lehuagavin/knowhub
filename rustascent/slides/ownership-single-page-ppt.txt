================================================================================
                Rust 所有权系统全景解析
================================================================================

布局：标题区 10% · 核心区 60% · 底部区 30%

────────────────────────────────────────────────────────────────────────────────
                              标题区
────────────────────────────────────────────────────────────────────────────────

标题：Rust 所有权系统全景解析
副标题：编译期内存安全 · 零运行时开销 · 无需 GC

────────────────────────────────────────────────────────────────────────────────
                        背景对比（标题下方）
────────────────────────────────────────────────────────────────────────────────

  ┌──────────┬──────────────────┬──────────────────┬──────────────────┐
  │          │ C/C++ 手动管理   │ Java/Go GC       │ Rust 所有权      │
  ├──────────┼──────────────────┼──────────────────┼──────────────────┤
  │ 机制     │ malloc / free    │ GC 运行时扫描    │ 编译期静态分析   │
  │ 代价     │ 悬垂指针、双重释放│ STW 停顿、高内存 │ 零开销、确定析构 │
  │ 并发安全 │ 无防护           │ 运行时检测       │ 编译期阻止竞争   │
  └──────────┴──────────────────┴──────────────────┴──────────────────┘


────────────────────────────────────────────────────────────────────────────────
                    核心区 —— 四层架构
────────────────────────────────────────────────────────────────────────────────

  【第一层：所有权规则】

  ① 每个值有且只有一个所有者
  ② 所有者离开作用域时，值自动释放（Drop）
  ③ 赋值默认 Move（零开销）；Copy trait 类型按位复制；堆类型需 .clone()


  【第二层：借用系统】

  &T  不可变借用：可同时多个（多读者）
  &mut T 可变借用：同一时刻仅一个（独占写者）
  核心约束：&T 与 &mut T 不能同时存在
  NLL：引用活跃范围按最后使用点计算，非词法作用域末尾


  【第三层：生命周期】

  核心原则：引用不能比被引用的值活得更久

  省略规则（编译器自动推断）：
  ① 每个引用参数获得独立生命周期
  ② 仅一个输入生命周期时，赋给所有输出
  ③ 含 &self / &mut self 时，其生命周期赋给输出

  无法推断时显式标注：fn longest<'a>(x: &'a str, y: &'a str) -> &'a str


  【第四层：智能指针与内部可变性】

  Box<T>          堆分配，单一所有权
  Rc<T> / Arc<T>  共享所有权（单线程 / 多线程）
  Cell<T>         内部可变，Copy 类型，零开销
  RefCell<T>      内部可变，运行时借用检查
  Mutex/RwLock<T> 内部可变，跨线程安全

  选型：堆分配？→ 共享？→ 跨线程？→ 内部可变？
        Box<T> → Rc<T> → Arc<T> → Arc<Mutex<T>>


────────────────────────────────────────────────────────────────────────────────
                    底部区 —— 实践与总结
────────────────────────────────────────────────────────────────────────────────

  【最佳实践】

  ① 优先借用而非转移
  ② 最小化可变性（默认 let）
  ③ 信任生命周期省略
  ④ 优先栈分配
  ⑤ 善用 cargo clippy


  【反模式警告】

  过度 .clone()        → 理清所有权归属，而非逃避借用检查
  滥用 Rc<RefCell<T>>  → 重新审视数据结构，避免退化为运行时检查
  对抗借用检查器        → 顺应编译器提示，改进所有权模型
  滥用 unsafe          → 穷尽安全方案后再考虑，并严格封装


                          【底部总结语】

          "与借用检查器的斗争，终将变成与借用检查器的合作。"

     编译期 > 运行时 | 显式 > 隐式 | 安全 > 便利 | 零成本抽象
