================================================================================
              Rust 无畏并发（Fearless Concurrency）
                        单页 PPT 文字描述
================================================================================


布局：上中下三段式（标题区 10% · 核心区 60% · 底部区 30%）


────────────────────────────────────────────────────────────────────────────────
                          标题区（约 10%）
────────────────────────────────────────────────────────────────────────────────

标题（居中，大字）：无畏并发 —— 编译通过，即无数据竞争

副标题（居中，小字）："如果它能编译，就不会有数据竞争。"
                      — Rust 社区格言

右上角标注：Rust 核心设计哲学之一


────────────────────────────────────────────────────────────────────────────────
                     核心区（约 60%）—— 左右两栏布局
────────────────────────────────────────────────────────────────────────────────

                        【左栏：三大编译期保障】

纵向排列三个卡片，每个卡片包含标题、代码示例、说明。

  ┌─────────────────────────────────────────────────┐
  │  ① 所有权 · Move 语义                           │
  │                                                 │
  │  示例：                                          │
  │    let data = vec![1, 2, 3];                    │
  │    std::thread::spawn(move || {                 │
  │        println!("{:?}", data);                  │
  │    });                                          │
  │    // println!("{:?}", data); // 编译错误！       │
  │                                                 │
  │  → 值 move 进线程后，原线程无法再访问             │
  │    从根本上消除共享可变状态                        │
  └─────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────┐
  │  ② 借用规则 · 读写锁语义                         │
  │                                                 │
  │  核心规则：                                       │
  │    同一时刻，要么 N 个 &T（共享只读）              │
  │              要么 1 个 &mut T（独占可写）          │
  │              二者不能同时存在                      │
  │                                                 │
  │  → 与防止数据竞争的条件完全一致                    │
  │    编译器充当静态"读写锁"                          │
  └─────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────┐
  │  ③ Send / Sync · 类型级线程安全标记               │
  │                                                 │
  │  Send：值可安全跨线程转移所有权                    │
  │  Sync：&T 可安全被多线程共享                      │
  │                                                 │
  │  反例：                                           │
  │    let rc = Rc::new(5);                         │
  │    std::thread::spawn(move || {                 │
  │        println!("{}", rc); // 编译错误！          │
  │    }); // Rc 不是 Send，编译器拒绝                │
  │                                                 │
  │  → 编译器自动推导，非线程安全类型无法跨线程         │
  └─────────────────────────────────────────────────┘


                  【右栏：安全共享状态 + 内存布局】

上半部分：共享可变状态的安全模式

  ┌─────────────────────────────────────────────────┐
  │  Arc<Mutex<T>> —— 并发共享可变数据的标准范式       │
  │                                                 │
  │  let counter = Arc::new(Mutex::new(0));         │
  │  for _ in 0..10 {                               │
  │      let c = Arc::clone(&counter);              │
  │      thread::spawn(move || {                    │
  │          let mut num = c.lock().unwrap();        │
  │          *num += 1;                             │
  │          // MutexGuard drop 时自动释放锁          │
  │      });                                        │
  │  }                                              │
  │                                                 │
  │  Arc  → 原子引用计数，安全共享所有权              │
  │  Mutex → 互斥锁，编译器强制先获取锁再访问数据     │
  │  RAII  → 锁离开作用域自动释放，不会忘记 unlock    │
  └─────────────────────────────────────────────────┘

下半部分：Mutex<T> 的 Send/Sync 条件

  ┌──────────────────┬──────────────────────────────┐
  │  Trait 约束       │  条件                        │
  ├──────────────────┼──────────────────────────────┤
  │  Mutex<T>: Send  │  T: Send                     │
  │  Mutex<T>: Sync  │  T: Send（不要求 T: Sync）    │
  └──────────────────┴──────────────────────────────┘

  为什么 Sync 只要求 T: Send？

  Mutex 保证同一时刻只有一个线程访问 T，
  不存在"多线程同时读"的场景，
  因此 T 本身不需要是 Sync 的。

  示例：Cell<i32> 不是 Sync，
        但 Mutex<Cell<i32>> 是 Sync ✓


────────────────────────────────────────────────────────────────────────────────
                    底部区（约 30%）—— 跨语言对比 + 总结
────────────────────────────────────────────────────────────────────────────────

                        【左侧：跨语言对比表】

  ┌──────────────┬────────────────┬────────────────┬────────────────┐
  │  并发问题      │  Rust          │  Java / Go     │  C / C++       │
  ├──────────────┼────────────────┼────────────────┼────────────────┤
  │  数据竞争      │ 编译期拒绝      │ 运行时异常/     │ 未定义行为(UB) │
  │              │               │ 靠程序员自觉     │ 难以排查        │
  ├──────────────┼────────────────┼────────────────┼────────────────┤
  │  忘记加锁      │ 类型系统强制    │ 不强制          │ 不强制          │
  │              │ 必须通过锁访问  │ 可直接访问字段   │ 可直接访问内存   │
  ├──────────────┼────────────────┼────────────────┼────────────────┤
  │  忘记释放锁    │ RAII 自动释放   │ 需手动/finally  │ 需手动 unlock   │
  │              │ 不可能遗忘      │ 可能遗忘        │ 可能遗忘        │
  ├──────────────┼────────────────┼────────────────┼────────────────┤
  │  线程安全标记  │ Send/Sync      │ 无编译期检查    │ 无编译期检查     │
  │              │ 编译器自动推导  │ 靠文档约定      │ 靠文档约定       │
  └──────────────┴────────────────┴────────────────┴────────────────┘

                     【右侧：无畏并发的四大支柱】

  用四个图标纵向排列：

  ⚙ 所有权系统   — move 语义确保数据单一归属，消除共享可变
  ⚡ 借用检查器   — 编译期读写锁，&T / &mut T 互斥规则
  🔒 Send/Sync  — 类型级线程安全标记，编译器自动推导
  🛠 RAII 锁管理 — MutexGuard 离开作用域自动释放，杜绝死锁


                          【底部总结语】

          "并发的恐惧来自运行时的不确定性。
     Rust 把这份恐惧前移到编译期：数据竞争变成编译错误，
           让你可以自信地编写并发代码 —— 这就是无畏并发。"
