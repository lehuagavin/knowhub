================================================================================
              Rust 显式优于隐式（Explicit is Better than Implicit）
                        单页 PPT 文字描述
================================================================================


布局：上中下三段式（标题区 10% · 核心区 60% · 底部区 30%）


────────────────────────────────────────────────────────────────────────────────
                          标题区（约 10%）
────────────────────────────────────────────────────────────────────────────────

标题（居中，大字）：显式优于隐式 —— 多写一行，少 debug 一夜

副标题（居中，小字）："代码被阅读的次数远多于被编写的次数。"

右上角标注：Rust 核心设计哲学之一


────────────────────────────────────────────────────────────────────────────────
                     核心区（约 60%）—— 左右两栏布局
────────────────────────────────────────────────────────────────────────────────

                      【左栏：三大显式机制】

纵向排列三个卡片，每个卡片包含标题、对比代码示例。

  ┌─────────────────────────────────────────────────┐
  │  ① 所有权与移动 · 数据流向显式可见               │
  │                                                 │
  │  fn take(s: String)        // 转移所有权         │
  │  fn borrow(s: &str)        // 借用              │
  │  fn mutate(s: &mut String) // 可变借用           │
  │                                                 │
  │  let s2 = s1;          // move，s1 失效         │
  │  let s3 = s2.clone();  // 显式拷贝              │
  │                                                 │
  │  → 移走、借用还是拷贝，调用处一目了然             │
  └─────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────┐
  │  ② 无隐式转换 · 错误必须处理                     │
  │                                                 │
  │  C:    double y = x;           // 隐式转换      │
  │  Rust: let y: f64 = x as f64;  // 必须显式      │
  │                                                 │
  │  Java: file.read()             // 异常可忽略     │
  │  Rust: File::open("a.txt")?;   // 必须处理      │
  │                                                 │
  │  → 类型转换和错误处理都是程序员的主动决策          │
  └─────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────┐
  │  ③ Trait 显式实现 · 不会意外满足接口              │
  │                                                 │
  │  Go:   func (m T) String() string { ... }       │
  │        // 自动满足 Stringer，无需声明             │
  │  Rust: impl Display for MyType { ... }          │
  │        // 必须显式声明实现关系                     │
  │                                                 │
  │  → 类型与 trait 的关系在代码中明确表达             │
  └─────────────────────────────────────────────────┘


                  【右栏：隐式 vs 显式 对比】

  ┌──────────────┬──────────────────┬──────────────────┐
  │  维度         │  隐式（其他语言） │  显式（Rust）     │
  ├──────────────┼──────────────────┼──────────────────┤
  │  类型转换     │  自动提升/截断    │  必须 as / into  │
  │  内存拷贝     │  赋值即拷贝       │  move 或 .clone()│
  │  错误处理     │  异常可被忽略     │  Result 必须处理  │
  │  可变性       │  默认可变         │  默认不可变 mut   │
  │  接口实现     │  鸭子类型/隐式    │  impl Trait 显式  │
  │  生命周期     │  GC 隐式管理      │  'a 标注显式声明  │
  └──────────────┴──────────────────┴──────────────────┘


────────────────────────────────────────────────────────────────────────────────
                    底部区（约 30%）—— 跨语言对比 + 总结
────────────────────────────────────────────────────────────────────────────────

                        【左侧：跨语言对比表】

  ┌──────────┬───────────────┬──────────────┬───────────────┐
  │  特性     │  Rust         │  Go          │  C / C++      │
  ├──────────┼───────────────┼──────────────┼───────────────┤
  │  类型转换  │ 必须显式 as   │ 必须显式      │ 隐式提升/转换  │
  │  错误处理  │ Result 强制   │ 可忽略 err   │ 易被忽略       │
  │  可变性   │ 默认不可变     │ 默认可变      │ 默认可变       │
  │  接口实现  │ impl 显式     │ 隐式鸭子类型  │ 继承/虚函数    │
  │  内存管理  │ 所有权，编译期 │ GC 隐式回收  │ 手动管理       │
  └──────────┴───────────────┴──────────────┴───────────────┘

                     【右侧：显式设计的四大收益】

  🔍 可读性   — 代码即文档，意图在字面上表达
  🛡 安全性   — 编译器验证越多，运行时 bug 越少
  🔧 可维护性 — 重构时编译器精确报告受影响之处
  ⚡ 可预测性 — 没有隐藏的性能开销和副作用


                          【底部总结语】

     "隐式是给编译器的便利，显式是给程序员的善意。
      写代码时多思考一步，读代码时少猜测十步。"
