================================================================================
              Rust 编译器保证（Compiler Guarantees）
                        单页 PPT 文字描述
================================================================================


布局：上中下三段式（标题区 10% · 核心区 60% · 底部区 30%）


────────────────────────────────────────────────────────────────────────────────
                          标题区（约 10%）
────────────────────────────────────────────────────────────────────────────────

标题（居中，大字）：编译器保证 —— 能编译，就能信赖

副标题（居中，小字）："如果它能编译通过，那它就能正确运行。"
                      — Rust 社区格言

右上角标注：Rust 核心设计哲学


────────────────────────────────────────────────────────────────────────────────
                     核心区（约 60%）—— 左右两栏布局
────────────────────────────────────────────────────────────────────────────────

                        【左栏：四大编译期保证】

纵向排列四个卡片，每个卡片包含标题、代码示例、编译器行为说明。

  ┌─────────────────────────────────────────────────┐
  │  ① 所有权 · 无悬垂指针（No Dangling Pointers）  │
  │                                                 │
  │  错误代码：                                      │
  │    let r;                                       │
  │    {                                            │
  │        let s = String::from("hello");           │
  │        r = &s;                                  │
  │    } // s 在此被释放                              │
  │    println!("{r}"); // 编译错误！                 │
  │                                                 │
  │  → 编译器追踪生命周期，引用不可能超过数据本身       │
  └─────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────┐
  │  ② 借用规则 · 无数据竞争（No Data Races）        │
  │                                                 │
  │  错误代码：                                      │
  │    let mut v = vec![1, 2, 3];                   │
  │    let r = &v[0];     // 不可变借用              │
  │    v.push(4);          // 可变借用               │
  │    println!("{r}");    // 编译错误！              │
  │                                                 │
  │  规则：同一时刻，要么 1 个 &mut，要么 N 个 &      │
  │  → push 可能触发重新分配，r 将成为悬垂指针        │
  │  → 编译器在编译期就阻止了这个运行时隐患            │
  └─────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────┐
  │  ③ 类型系统 · 无空指针（No Null Pointers）       │
  │                                                 │
  │  Rust 没有 null，用 Option<T> 代替：              │
  │    fn find_user(id: u32) -> Option<User> {      │
  │        ...                                      │
  │    }                                            │
  │    match find_user(42) {                        │
  │        Some(user) => println!("{}", user.name), │
  │        None => println!("未找到"),               │
  │    }                                            │
  │                                                 │
  │  → 编译器强制处理"值不存在"的情况，遗漏即报错     │
  └─────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────┐
  │  ④ Send/Sync · 线程安全（Thread Safety）         │
  │                                                 │
  │  错误代码：                                      │
  │    let rc = Rc::new(42);                        │
  │    std::thread::spawn(move || {                 │
  │        println!("{rc}"); // 编译错误！            │
  │    });                                          │
  │                                                 │
  │  Rc<T> 未实现 Send，不能跨线程传递                │
  │  → 需要用 Arc<T>（原子引用计数）替代              │
  │  → 编译器自动判断类型的线程安全性                  │
  └─────────────────────────────────────────────────┘


                  【右栏：C/C++ vs Rust 同场景对比】

上半部分：同一 Bug 在两种语言中的命运

  ┌─────────────────────────────────────────────────┐
  │                  C++ 的世界                      │
  │                                                 │
  │  std::vector<int> v = {1, 2, 3};               │
  │  int& r = v[0];                                │
  │  v.push_back(4);   // 可能重新分配内存           │
  │  std::cout << r;   // 未定义行为！               │
  │                                                 │
  │  编译器：✅ 编译通过，不报任何警告                 │
  │  运行时：💥 可能崩溃，可能"碰巧正确"              │
  │          可能在生产环境凌晨三点出问题              │
  └─────────────────────────────────────────────────┘
                         ↕ 对比
  ┌─────────────────────────────────────────────────┐
  │                  Rust 的世界                     │
  │                                                 │
  │  let mut v = vec![1, 2, 3];                     │
  │  let r = &v[0];                                 │
  │  v.push(4);                                     │
  │  println!("{r}");                                │
  │                                                 │
  │  编译器：❌ 拒绝编译，明确指出冲突位置             │
  │  运行时：根本不会运行，bug 在编译期已消灭          │
  └─────────────────────────────────────────────────┘

下半部分：错误发现时机示意图

  开发流程时间线：
  编码 ──→ 编译 ──→ 测试 ──→ 部署 ──→ 生产运行
             │               │               │
             │               │               │
  Rust ──────┘               │               │
  编译期就拦住                 │               │
                              │               │
  Java/Go ────────────────────┘               │
  运行时 panic/异常                            │
                                              │
  C/C++ ──────────────────────────────────────┘
  凌晨三点 core dump

  → 越早发现 bug，修复成本越低


────────────────────────────────────────────────────────────────────────────────
                    底部区（约 30%）—— 保证全景 + 设计取舍
────────────────────────────────────────────────────────────────────────────────

                     【左侧：编译器保证全景表】

  ┌──────────────┬──────────────────┬──────────────────┐
  │  Bug 类型     │  C/C++           │  Rust            │
  ├──────────────┼──────────────────┼──────────────────┤
  │  空指针解引用  │  运行时崩溃       │  不存在 null      │
  │  悬垂指针     │  未定义行为       │  编译期拒绝        │
  │  Double Free │  运行时崩溃       │  所有权系统阻止    │
  │  数据竞争     │  运行时偶发       │  借用规则阻止      │
  │  缓冲区溢出   │  安全漏洞         │  边界检查 + 类型   │
  │  未处理错误   │  静默忽略         │  Result 强制处理   │
  │  类型混淆     │  隐式转换         │  无隐式转换        │
  └──────────────┴──────────────────┴──────────────────┘

                     【右侧：设计取舍四象限】

  用四个图标纵向排列：

  📈 学习曲线   — 陡峭，需要理解所有权/生命周期/借用
  🐢 编译速度   — 较慢，编译器做了大量静态分析
  🔓 逃生舱口   — unsafe 块允许绕过检查，承担手动责任
  🎯 回报       — 一旦编译通过，整类 bug 不复存在


                          【底部总结语】

          "与其在凌晨三点被线上 core dump 叫醒，
     不如在编译时就让编译器告诉你哪里有问题。
           编译器是最严格的 Code Reviewer
       —— 它不放过任何一个潜在的内存或并发错误。"
