================================================================================
                Rust 实用主义哲学（Pragmatism Philosophy）
                          单页 PPT 文字描述
================================================================================


布局：上中下三段式（标题区 10% · 核心区 60% · 底部区 30%）


────────────────────────────────────────────────────────────────────────────────
                          标题区（约 10%）
────────────────────────────────────────────────────────────────────────────────

标题（居中，大字）：实用主义 —— 不为纯粹而纯粹，只为好用而设计

副标题（居中，小字）："Rust 在每个设计决策上都在问：这对写真实软件的程序员有用吗？"

右上角标注：Rust 核心设计哲学


────────────────────────────────────────────────────────────────────────────────
                     核心区（约 60%）—— 左右两栏布局
────────────────────────────────────────────────────────────────────────────────

                        【左栏：三大务实设计】

纵向排列三个卡片，每个卡片包含标题、代码示例、设计意图说明。

  ┌─────────────────────────────────────────────────┐
  │  ① 多范式 · 不教条（Multi-Paradigm）             │
  │                                                 │
  │  函数式风格：                                     │
  │    let r: Vec<_> = data.iter()                   │
  │        .map(|x| x * 2).collect();               │
  │                                                 │
  │  命令式风格：                                     │
  │    let mut r = Vec::new();                       │
  │    for x in &data { r.push(x * 2); }            │
  │                                                 │
  │  → 哪种清晰用哪种，没有范式信仰                    │
  └─────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────┐
  │  ② unsafe · 承认现实（Pragmatic Escape Hatch）   │
  │                                                 │
  │  安全接口，内部隔离 unsafe：                       │
  │    pub fn split_at_mut(slice: &mut [i32],       │
  │        mid: usize) -> (&mut [i32], &mut [i32])  │
  │    {                                            │
  │        unsafe { /* 程序员保证正确性 */ }           │
  │    }                                            │
  │                                                 │
  │  适用场景：FFI 调用 C 库 / OS 驱动 / 嵌入式       │
  │  → 不假装需求不存在，而是把风险控制在最小范围        │
  └─────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────┐
  │  ③ 编译器 · 可用的错误信息（Helpful Errors）      │
  │                                                 │
  │  error[E0382]: borrow of moved value: `s1`      │
  │    --> src/main.rs:5:20                          │
  │  3 | let s1 = String::from("hello");            │
  │  4 | let s2 = s1;                               │
  │        -- value moved here                      │
  │  5 | println!("{}", s1);                         │
  │                     ^^ borrowed after move       │
  │    = help: consider cloning the value            │
  │                                                 │
  │  → 指出哪里错、为什么错、怎么修，不是学术追求        │
  │    而是工程实用性                                  │
  └─────────────────────────────────────────────────┘


                  【右栏：渐进式设计 + 生态策略】

上半部分：渐进式学习曲线表格

  ┌────────────────┬────────────────────────────────────┐
  │    复杂概念    │          实用的简化版              │
  ├────────────────┼────────────────────────────────────┤
  │ 生命周期标注   │ 省略规则，大多数情况不用写         │
  ├────────────────┼────────────────────────────────────┤
  │ 手动内存管理   │ Box, Rc, Arc 智能指针              │
  ├────────────────┼────────────────────────────────────┤
  │ 复杂并发原语   │ rayon 一行实现并行迭代             │
  ├────────────────┼────────────────────────────────────┤
  │ 异步运行时     │ tokio + async/await 语法糖         │
  └────────────────┴────────────────────────────────────┘

  设计意图：不需要一开始就理解所有底层细节，先用起来再深入

下半部分：标准库 + 生态策略示意

  ┌─────────────────────────────────────────────────┐
  │          标准库"够用但不臃肿"                     │
  │                                                 │
  │  标准库（精简核心）                                │
  │  ┌───────────────────────────────────┐           │
  │  │ Vec / HashMap / String / IO ...  │           │
  │  └───────────────────────────────────┘           │
  │              ↕ Cargo 无摩擦引入                   │
  │  crates.io（社区生态）                             │
  │  ┌──────┐ ┌──────┐ ┌───────┐ ┌──────┐          │
  │  │ regex│ │ reqw │ │ tokio │ │serde │          │
  │  └──────┘ └──────┘ └───────┘ └──────┘          │
  │                                                 │
  │  策略：标准库稳定不可破坏性更改                     │
  │        生态库快速迭代、竞争、淘汰                   │
  └─────────────────────────────────────────────────┘


────────────────────────────────────────────────────────────────────────────────
                    底部区（约 30%）—— Edition 机制 + 总结
────────────────────────────────────────────────────────────────────────────────

                 【左侧：Edition 机制 —— 稳定性与演进的平衡】

  时间轴（横向箭头）：

  2015 ──────► 2018 ──────► 2021 ──────► 2024
  Edition      Edition      Edition      Edition

  核心规则：
  ┌─────────────────────────────────────────────────────────┐
  │  ✓ 2015 年编译通过的代码，今天依然能编译通过              │
  │  ✓ 不同 Edition 的 crate 可以互相依赖                    │
  │  ✓ cargo fix --edition 自动迁移代码                      │
  └─────────────────────────────────────────────────────────┘

  迁移流程：
    cargo fix --edition  →  修改 Cargo.toml edition  →  cargo build 验证
    （自动改代码）           （切换版本）                 （确认正常）


                     【右侧：六大实用主义支柱】

  用六个图标纵向排列：

  🔀 多范式       — 函数式 + 命令式 + OOP，不强迫选边
  🔓 unsafe 隔离  — 承认现实需求，把风险控制在最小范围
  💡 友好报错     — 编译器告诉你哪里错、为什么、怎么修
  📈 渐进学习     — 提供简化版本，先用起来再深入理解
  📦 精简标准库   — 核心稳定，生态自由迭代
  🔄 Edition 机制 — 语言演进但不破坏已有代码


                          【底部总结语】

          "不为了理论上的优雅而牺牲实际可用性，
           也不为了方便而放弃安全底线。
     Rust 既有学术语言的严谨性，又有工程语言的实用性——
              因为它始终在为真实世界的程序员设计。"
