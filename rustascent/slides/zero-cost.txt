================================================================================
              Rust 零成本抽象（Zero-Cost Abstractions）
                        单页 PPT 文字描述
================================================================================


布局：上中下三段式（标题区 10% · 核心区 60% · 底部区 30%）


────────────────────────────────────────────────────────────────────────────────
                          标题区（约 10%）
────────────────────────────────────────────────────────────────────────────────

标题（居中，大字）：零成本抽象 —— 写得优雅，跑得飞快

副标题（居中，小字）："你不用的东西，不为之付出代价；你用的东西，手写也不会更好。"
                      — Bjarne Stroustrup

右上角标注：Rust 核心设计原则之一


────────────────────────────────────────────────────────────────────────────────
                     核心区（约 60%）—— 左右两栏布局
────────────────────────────────────────────────────────────────────────────────

                        【左栏：三大机制】

纵向排列三个卡片，每个卡片包含标题、代码示例、编译结果说明。

  ┌─────────────────────────────────────────────────┐
  │  ① 泛型 · 单态化（Monomorphization）            │
  │                                                 │
  │  源码：                                          │
  │    fn add<T: Add<Output=T>>(a: T, b: T) -> T   │
  │    { a + b }                                    │
  │                                                 │
  │  编译后展开为：                                   │
  │    fn add_i32(a: i32, b: i32) -> i32            │
  │    fn add_f64(a: f64, b: f64) -> f64            │
  │                                                 │
  │  → 每个具体类型生成专用函数，直接调用              │
  └─────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────┐
  │  ② 迭代器 · 内联优化（Inlining）                │
  │                                                 │
  │  高级写法：                                       │
  │    (0..100).filter(|x| x%2==0).sum()            │
  │                                                 │
  │  等价于手写：                                     │
  │    let mut sum = 0;                             │
  │    for i in 0..100 {                            │
  │        if i % 2 == 0 { sum += i; }              │
  │    }                                            │
  │                                                 │
  │  → 编译器内联展开，生成相同机器码                  │
  └─────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────┐
  │  ③ Trait · 静态分发（Static Dispatch）           │
  │                                                 │
  │  fn print_area(shape: &impl Shape)              │
  │                                                 │
  │  编译后展开为：                                   │
  │    fn print_area_circle(s: &Circle)             │
  │    fn print_area_rect(s: &Rect)                 │
  │                                                 │
  │  → 编译期确定调用目标，无需虚函数表                │
  └─────────────────────────────────────────────────┘


                  【右栏：静态分发 vs 动态分发 对比】

上半部分：对比表格

  ┌──────────────┬──────────────────┬──────────────────┐
  │              │  impl Trait      │  dyn Trait        │
  │              │  （静态分发）     │  （动态分发）      │
  ├──────────────┼──────────────────┼──────────────────┤
  │  分发时机     │  编译期          │  运行时            │
  │  实现机制     │  单态化          │  vtable 间接调用   │
  │  能否内联     │  能              │  不能              │
  │  运行时开销   │  零              │  有（指针查找）     │
  │  二进制体积   │  较大（代码膨胀） │  较小              │
  │  异构集合     │  不支持          │  支持              │
  └──────────────┴──────────────────┴──────────────────┘

下半部分：dyn Trait 内存布局示意图

  Box<dyn Shape> 胖指针：
  ┌────────────┬────────────┐
  │  数据指针   │ vtable 指针 │
  └─────┬──────┴─────┬──────┘
        │            │
        ▼            ▼
   堆上具体对象    虚函数表
   (Circle/Rect)  ┌──────────────┐
                  │ area() 地址   │
                  │ name() 地址   │
                  └──────────────┘

  调用路径：读 vtable → 取函数指针 → 间接跳转


────────────────────────────────────────────────────────────────────────────────
                    底部区（约 30%）—— 跨语言对比 + 总结
────────────────────────────────────────────────────────────────────────────────

                        【左侧：跨语言对比表】

  ┌──────────┬────────────────┬────────────────┬────────────────┐
  │  特性     │  Rust          │  Java / Go     │  C / C++       │
  ├──────────┼────────────────┼────────────────┼────────────────┤
  │  泛型     │ 单态化，零开销  │ 类型擦除/装箱   │ C++ 模板类似    │
  │          │               │ 有运行时开销     │ C 无泛型        │
  ├──────────┼────────────────┼────────────────┼────────────────┤
  │  迭代器   │ 编译期优化消除  │ 对象分配+虚调用 │ C++ 可优化      │
  │          │               │               │ C 无迭代器抽象   │
  ├──────────┼────────────────┼────────────────┼────────────────┤
  │  内存管理  │ 所有权系统     │ GC 运行时       │ 手动管理        │
  │          │ 编译期，零开销  │ 有 STW 停顿     │ 零开销但不安全   │
  ├──────────┼────────────────┼────────────────┼────────────────┤
  │  多态     │ 默认静态分发    │ 默认虚函数      │ C++ 虚函数      │
  │          │ 可选 dyn 动态  │ 始终有开销      │ C 函数指针       │
  └──────────┴────────────────┴────────────────┴────────────────┘

                     【右侧：实现零成本的四大支柱】

  用四个图标纵向排列：

  ⚙ 单态化     — 泛型编译期展开为具体类型代码
  ⚡ 内联优化   — 小函数和闭包内联到调用处
  🔒 所有权系统 — 编译期管理内存，无需 GC
  🛠 LLVM 后端 — 进一步消除冗余，极致优化


                          【底部总结语】

          "抽象是给程序员的，不是给 CPU 的。
     Rust 让你写出高级、可读的代码，编译器保证它和手写底层代码一样快。
           你为抽象付出的代价在编译期，而不是运行时。"
