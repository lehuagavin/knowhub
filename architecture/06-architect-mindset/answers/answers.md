# 第六章 架构师思维 - 习题答案

## 一、选择题

### 1. 答案：B
同一个概念在不同限界上下文中可以有不同的含义。例如"用户"在账户上下文中是登录凭证，在订单上下文中是下单人，在物流上下文中是收件人。限界上下文的大小应该根据业务复杂度决定，不是越小越好。

### 2. 答案：C
关注点分离是一个正确的设计原则，不是反模式。简历驱动开发（为简历引入不必要技术）、分布式单体（名义微服务实际强耦合）、金锤子（用熟悉技术解决所有问题）都是架构反模式。

### 3. 答案：B
ADR的核心价值是记录架构决策的背景（为什么做这个决策）和理由（为什么选择这个方案而非其他方案）。它不是代码注释的替代品，也不是项目管理工具。

### 4. 答案：C
演进式架构的核心观点是架构应该随业务发展而演进，不应该在项目初期就试图设计出"最终架构"。过早引入复杂架构是过度设计，适应度函数用于持续验证架构质量。

### 5. 答案：B
聚合根是聚合的入口点，负责保证聚合内部的一致性。外部只能通过聚合根访问聚合内的实体，不能直接操作聚合内部的对象。这保证了业务规则的完整性。

---

## 二、简答题

### 6. 通用语言（Ubiquitous Language）

**概念：** 通用语言是DDD中的核心概念，指开发团队和业务专家共同使用的、精确的、无歧义的语言。这套语言贯穿于需求讨论、代码实现、文档编写的全过程。

**重要性：**
- 消除沟通歧义：业务人员和技术人员使用相同的术语
- 代码即文档：代码中的类名、方法名直接反映业务概念
- 减少翻译成本：不需要在"业务语言"和"技术语言"之间转换

**实际例子：**

在电商系统中，业务人员说"退款"，开发人员可能理解为：
- 退回到原支付方式？
- 退回到账户余额？
- 部分退款还是全额退款？
- 退款后库存是否恢复？

通过建立通用语言：
```
退款（Refund）：将已支付的金额退回到用户的原支付方式
部分退款（Partial Refund）：退回订单中部分商品的金额
退货退款（Return Refund）：用户退回商品后触发的退款，同时恢复库存
仅退款（Refund Only）：不退货只退款，不恢复库存
```

代码中直接使用这些术语：
```python
class RefundService:
    def create_partial_refund(self, order_id, items): ...
    def create_return_refund(self, order_id, items): ...
    def create_refund_only(self, order_id, reason): ...
```

### 7. 技术选型评估

**关键维度：**

| 维度 | MySQL | PostgreSQL | MongoDB |
|------|-------|-----------|---------|
| 成熟度 | 非常成熟 | 非常成熟 | 成熟 |
| 数据模型 | 关系型 | 关系型 | 文档型 |
| 事务支持 | 完善 | 完善（更强） | 4.0+支持多文档事务 |
| JSON支持 | 5.7+支持 | 原生JSONB，性能好 | 原生支持 |
| 扩展性 | 主从复制，分库分表较复杂 | 主从复制，Citus扩展 | 原生分片，水平扩展好 |
| 团队经验 | 需评估 | 需评估 | 需评估 |
| 运维生态 | 非常丰富 | 丰富 | 丰富 |
| 适用场景 | 通用OLTP | 复杂查询、GIS | 灵活Schema、文档存储 |

**评估建议：**
1. 如果团队有MySQL经验且业务是标准OLTP → MySQL
2. 如果需要复杂查询、JSON处理、GIS功能 → PostgreSQL
3. 如果数据Schema变化频繁、需要水平扩展 → MongoDB
4. 最重要的因素往往是团队经验——选择团队最熟悉的技术，除非有明确的技术原因不能用

### 8. 分布式单体反模式

**定义：** 分布式单体是指系统在物理上拆分为多个服务，但在逻辑上仍然是强耦合的。服务之间存在大量同步调用、共享数据库、需要同时部署等问题。

**产生原因：**
1. 按技术层而非业务能力拆分（如把Controller、Service、DAO拆成三个服务）
2. 服务间共享数据库，通过数据库进行隐式通信
3. 服务间接口设计不合理，存在大量细粒度的同步调用
4. 没有明确的服务边界，服务间存在循环依赖
5. 缺乏API版本管理，接口变更需要多个服务同时发布

**如何避免：**
1. 按业务能力拆分服务，每个服务对应一个限界上下文
2. 数据库独立：每个服务拥有自己的数据库，通过API而非数据库共享数据
3. 优先使用异步通信（消息队列），减少同步调用链
4. 服务间通过API契约通信，使用版本管理保证向后兼容
5. 每个服务可以独立部署、独立测试
6. 检查指标：如果每次发布都需要同时部署多个服务，说明存在分布式单体问题

---

## 三、设计题

### 9. 在线教育平台领域建模

**核心领域和子域：**
```
核心域：课程学习（平台的核心价值）
支撑域：课程管理、用户管理
通用域：支付、通知、认证
```

**限界上下文：**
```
1. 课程管理上下文：课程的创建、编辑、发布
2. 学习上下文：学习进度、课时完成、证书发放
3. 交易上下文：课程购买、订单管理
4. 用户上下文：用户注册、角色管理（讲师/学生）
```

**聚合设计：**

```
课程管理上下文：
  聚合根：Course（课程）
  实体：Chapter（章节）、Lesson（课时）
  值对象：CourseTitle、Price
  规则：课程至少有一个章节，章节至少有一个课时

学习上下文：
  聚合根：Enrollment（选课记录）
  实体：LessonProgress（课时进度）
  值对象：ProgressStatus（未开始/进行中/已完成）
  规则：所有课时完成后可以申请证书

交易上下文：
  聚合根：Order（订单）
  值对象：Money、PaymentMethod
```

**领域事件：**
```
- CoursePublished（课程发布）→ 通知关注该讲师的学生
- CoursePurchased（课程购买）→ 创建选课记录、通知讲师
- LessonCompleted（课时完成）→ 更新学习进度
- AllLessonsCompleted（所有课时完成）→ 生成结业证书
- CertificateIssued（证书发放）→ 通知学生
```

### 10. 架构评审

**问题分析：**

这个方案对于一个500人的内部管理系统来说严重过度设计。

**具体问题：**

1. **10个微服务过多：** 500人的内部系统，业务复杂度有限，10个微服务带来的运维成本远超收益。服务间调用、分布式事务、数据一致性等问题会大幅增加开发和运维难度。

2. **Kubernetes + Istio过重：** 内部管理系统不需要复杂的容器编排和服务网格。Kubernetes的学习和运维成本很高，Istio更是增加了额外的复杂度。

3. **Kafka集群不必要：** 500人的系统QPS很低，不需要Kafka这种百万级吞吐的消息队列。如果确实需要异步处理，一个简单的Redis队列或RabbitMQ单节点就够了。

4. **Redis Cluster 6节点过多：** 500人系统的缓存数据量很小，单个Redis实例绑绑有余。

5. **每个微服务独立PostgreSQL：** 10个数据库实例的运维成本很高，且跨服务查询变得复杂。

**改进建议：**

```
简化方案：
  前端：React + TypeScript（保留，合理选择）
  后端：单体应用或2-3个服务（按核心业务域拆分）
  数据库：单个PostgreSQL实例（读写分离都不需要）
  缓存：单个Redis实例（如果确实需要缓存）
  部署：Docker Compose 或直接部署到VM
  监控：简单的日志 + 基础指标监控

理由：
  - 500人的内部系统，单体应用完全可以胜任
  - 开发效率高，调试方便，运维简单
  - 如果未来业务增长，再逐步拆分（演进式架构）
  - 节省的基础设施成本和运维人力可以投入到业务功能开发
```

**核心原则：** 架构的复杂度应该与业务的复杂度匹配。用大炮打蚊子不是好的架构设计。
