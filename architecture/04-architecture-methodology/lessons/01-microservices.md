# 微服务架构

## 一、从单体到微服务

### 1.1 单体架构的优缺点

**单体架构**是将所有功能模块打包在一个部署单元中的架构风格。

```
┌─────────────────────────────────┐
│           单体应用               │
│  ┌─────┐ ┌─────┐ ┌─────┐      │
│  │用户  │ │订单  │ │支付  │      │
│  │模块  │ │模块  │ │模块  │      │
│  └──┬──┘ └──┬──┘ └──┬──┘      │
│     └───────┼───────┘          │
│          ┌──▼──┐               │
│          │数据库│               │
│          └─────┘               │
└─────────────────────────────────┘
```

**优点：**
- 开发简单，IDE 支持好
- 部署简单，一个包搞定
- 调试方便，本地可以跑完整系统
- 事务简单，本地事务即可

**缺点（随规模增长暴露）：**
- 代码耦合严重，修改一处可能影响全局
- 构建和部署慢，改一行代码要重新部署整个系统
- 技术栈锁定，无法为不同模块选择最合适的技术
- 扩展粒度粗，无法针对热点模块单独扩容
- 故障传播，一个模块的 OOM 可能拖垮整个系统

### 1.2 微服务的定义

微服务架构是将应用拆分为一组小型、自治的服务，每个服务：
- 围绕业务能力构建
- 独立部署、独立扩展
- 拥有自己的数据存储
- 通过轻量级协议通信（HTTP/gRPC）

```
┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐
│用户   │  │订单   │  │支付   │  │库存   │
│服务   │  │服务   │  │服务   │  │服务   │
└──┬───┘  └──┬───┘  └──┬───┘  └──┬───┘
   │         │         │         │
┌──▼──┐  ┌──▼──┐  ┌──▼──┐  ┌──▼──┐
│MySQL│  │MySQL│  │MySQL│  │Redis│
└─────┘  └─────┘  └─────┘  └─────┘
```

### 1.3 什么时候该拆微服务

**不要过早拆分。** 微服务带来的复杂度远超大多数人的预期。

拆分的信号：
- 团队规模超过 10 人，代码冲突频繁
- 不同模块的发布节奏差异大
- 某个模块需要独立扩容（如搜索服务需要更多 CPU）
- 团队希望使用不同的技术栈

不该拆分的信号：
- 团队只有 3-5 人
- 业务逻辑还在快速变化，边界不清晰
- 只是因为"微服务很流行"

---

## 二、服务拆分原则

### 2.1 按业务能力拆分

根据业务领域划分服务边界，每个服务对应一个业务能力。

```
电商系统拆分示例：
- 用户服务：注册、登录、用户信息管理
- 商品服务：商品CRUD、分类管理、搜索
- 订单服务：下单、订单查询、订单状态管理
- 支付服务：支付、退款、对账
- 库存服务：库存扣减、库存查询
- 物流服务：发货、物流跟踪
- 通知服务：短信、邮件、推送
```

### 2.2 拆分粒度的判断

**过粗的问题：** 服务内部耦合严重，失去了微服务的优势
**过细的问题：** 服务间调用链过长，运维复杂度爆炸

判断标准：
- 一个服务由一个小团队（2-8人）负责
- 服务的代码量在一个人能完全理解的范围内
- 服务可以在两周内完全重写

### 2.3 数据库拆分

微服务的核心原则之一是**数据库独立**：每个服务拥有自己的数据库，其他服务不能直接访问。

```
错误做法：
  服务A ──→ 共享数据库 ←── 服务B
  （数据库成为隐式耦合点）

正确做法：
  服务A ──→ 数据库A
  服务B ──→ 数据库B
  服务A 需要服务B 的数据时，通过 API 调用
```

---

## 三、服务间通信

### 3.1 同步通信

**HTTP/REST：**
- 简单通用，生态成熟
- 适合对外 API 和简单的服务间调用
- 缺点：性能相对较低，序列化开销大

**gRPC：**
- 基于 HTTP/2 和 Protocol Buffers
- 高性能，支持流式传输
- 强类型接口定义（.proto 文件）
- 适合内部服务间的高频调用

```protobuf
// user.proto
service UserService {
    rpc GetUser(GetUserRequest) returns (User);
    rpc ListUsers(ListUsersRequest) returns (stream User);
}

message GetUserRequest {
    int64 user_id = 1;
}

message User {
    int64 id = 1;
    string name = 2;
    string email = 3;
}
```

### 3.2 异步通信

通过消息队列实现服务间的异步解耦。

```
同步调用的问题：
  订单服务 → 库存服务 → 支付服务 → 通知服务
  （链式调用，任何一环失败都会导致整体失败）

异步解耦：
  订单服务 → [消息队列] → 库存服务
                       → 支付服务
                       → 通知服务
  （订单服务只需发送消息，不关心下游处理结果）
```

**选择同步还是异步：**
- 需要立即获得结果 → 同步
- 可以容忍延迟 → 异步
- 下游服务不可用时不应阻塞上游 → 异步
- 需要广播给多个消费者 → 异步

---

## 四、服务治理

### 4.1 服务注册与发现

```
服务注册：
  服务启动时，向注册中心注册自己的地址
  服务停止时，从注册中心注销

服务发现：
  调用方从注册中心获取目标服务的地址列表
  根据负载均衡策略选择一个地址发起调用

常用注册中心：
  - Consul：支持健康检查、KV存储、多数据中心
  - etcd：基于Raft，Kubernetes默认使用
  - Nacos：阿里开源，支持配置管理
  - ZooKeeper：老牌选手，但运维复杂
```

### 4.2 负载均衡

```
服务端负载均衡：
  客户端 → Nginx/ALB → 服务实例A
                     → 服务实例B
                     → 服务实例C

客户端负载均衡：
  客户端（内置LB） → 服务实例A
                   → 服务实例B
                   → 服务实例C

常用策略：
  - 轮询（Round Robin）：依次分配
  - 加权轮询：按权重分配
  - 最少连接：选择当前连接数最少的实例
  - 一致性哈希：相同请求路由到相同实例（适合有状态场景）
```

### 4.3 API 网关

API 网关是微服务架构的统一入口，负责横切关注点。

```
客户端 → API网关 → 用户服务
                 → 订单服务
                 → 商品服务

网关职责：
  - 路由转发
  - 认证鉴权
  - 限流熔断
  - 协议转换（HTTP → gRPC）
  - 请求聚合（BFF模式）
  - 日志与监控

常用网关：
  - Kong：基于Nginx，插件丰富
  - APISIX：国产高性能网关
  - Spring Cloud Gateway：Java生态
  - Envoy：云原生代理
```

### 4.4 配置中心

集中管理所有服务的配置，支持动态更新。

```
功能要求：
  - 集中存储所有服务的配置
  - 支持多环境（dev/staging/prod）
  - 配置变更实时推送
  - 配置版本管理和回滚
  - 敏感配置加密

常用方案：
  - Apollo（携程开源）：功能最全面
  - Nacos：配置管理 + 服务发现
  - Spring Cloud Config：Git-based
  - etcd/Consul KV：轻量级方案
```

---

## 五、可观测性

### 5.1 三大支柱

```
日志（Logging）：
  - 记录离散事件
  - 工具：ELK（Elasticsearch + Logstash + Kibana）、Loki
  - 关键：结构化日志（JSON格式）、统一日志格式、关联TraceID

指标（Metrics）：
  - 可聚合的数值数据
  - 工具：Prometheus + Grafana
  - 关键指标：QPS、延迟（P50/P95/P99）、错误率、饱和度

追踪（Tracing）：
  - 跟踪请求在多个服务间的调用链路
  - 工具：Jaeger、Zipkin、SkyWalking
  - 关键：每个请求分配唯一TraceID，跨服务传递
```

### 5.2 监控告警

```
RED方法（面向服务）：
  - Rate：请求速率
  - Errors：错误率
  - Duration：请求耗时

USE方法（面向资源）：
  - Utilization：利用率（CPU、内存、磁盘）
  - Saturation：饱和度（队列长度、等待数）
  - Errors：错误数

告警原则：
  - 只告警需要人工介入的问题
  - 告警信息要包含足够的上下文
  - 避免告警风暴（合并、抑制、分级）
```

---

## 六、微服务的代价

微服务不是银弹，它带来的复杂度包括：

1. **分布式系统的固有复杂性**：网络不可靠、部分失败、数据一致性
2. **运维复杂度**：几十上百个服务的部署、监控、排障
3. **测试复杂度**：集成测试、契约测试、端到端测试
4. **数据一致性**：跨服务事务需要 Saga/TCC 等方案
5. **调试困难**：一个请求可能经过十几个服务
6. **团队协作成本**：服务间接口变更需要协调

**Martin Fowler 的建议：** 如果你无法构建一个结构良好的单体应用，那你也无法构建一个结构良好的微服务系统。先把单体做好，再考虑拆分。
