# 实战案例：短链服务设计

## 一、概述

短链服务（URL Shortener）是系统设计中最经典的入门案例之一。它的核心功能简单明了：将一个长URL转换为一个短URL，用户访问短URL时重定向到原始长URL。

虽然功能看似简单，但一个生产级的短链服务涉及到ID生成、哈希算法、缓存策略、数据库设计、高可用等多个技术点，是学习系统设计的绝佳案例。

知名的短链服务包括：bit.ly、tinyurl.com、t.cn（新浪短链）等。

---

## 二、需求分析

### 2.1 功能需求

```
核心功能：
1. 创建短链：用户提交一个长URL，系统返回一个短URL
2. 短链跳转：用户访问短URL，系统302重定向到原始长URL
3. 自定义短码：用户可以指定自定义的短码（可选）
4. 过期时间：短链接可以设置过期时间（可选）

扩展功能：
5. 访问统计：记录短链接的访问次数、来源、地域分布
6. 批量创建：支持批量提交长URL生成短链
7. API接口：提供RESTful API供第三方调用
```

### 2.2 非功能需求

```
1. 高可用性：99.99%（短链跳转是核心功能，不能挂）
2. 低延迟：短链跳转 < 50ms（用户体验要求）
3. 高吞吐：支持高并发的读请求
4. 持久性：短链映射关系不能丢失
5. 唯一性：同一个短码不能映射到不同的长URL
6. 不可预测性：短码不能被轻易猜测（安全考虑）
```

### 2.3 API 设计

```
# 创建短链
POST /api/v1/shorten
Request:
{
    "long_url": "https://www.example.com/very/long/path?param=value",
    "custom_alias": "mylink",     // 可选
    "expire_at": "2025-12-31"     // 可选
}
Response:
{
    "short_url": "https://s.cn/abc123",
    "short_code": "abc123",
    "expire_at": "2025-12-31",
    "created_at": "2024-01-01T00:00:00Z"
}

# 短链跳转
GET /{short_code}
Response: HTTP 302 Redirect → Location: {long_url}

# 查看统计
GET /api/v1/stats/{short_code}
Response:
{
    "short_code": "abc123",
    "long_url": "https://www.example.com/...",
    "total_clicks": 12345,
    "created_at": "2024-01-01T00:00:00Z"
}
```

---

## 三、容量估算

### 3.1 基本假设

```
- 日活用户（DAU）：1000万
- 每日新建短链数：1000万条（写）
- 读写比：100:1（读远大于写）
- 每日读请求：10亿次
- 数据保存时间：5年
```

### 3.2 QPS 估算

```
写QPS：
  10,000,000 / 86,400 ≈ 116 QPS
  峰值写QPS ≈ 116 × 3 ≈ 350 QPS

读QPS：
  1,000,000,000 / 86,400 ≈ 11,574 QPS
  峰值读QPS ≈ 11,574 × 3 ≈ 35,000 QPS
```

### 3.3 存储量估算

```
每条短链记录大小：
  - short_code: 7 bytes
  - long_url: 平均 200 bytes
  - created_at: 8 bytes
  - expire_at: 8 bytes
  - user_id: 8 bytes
  - 其他元数据: 约 70 bytes
  合计：约 300 bytes

5年总存储量：
  10,000,000 × 365 × 5 × 300 bytes
  = 18,250,000,000 × 300 bytes
  ≈ 5.5 TB
```

### 3.4 带宽估算

```
读带宽：
  35,000 QPS × 300 bytes ≈ 10.5 MB/s ≈ 84 Mbps

写带宽：
  350 QPS × 300 bytes ≈ 105 KB/s ≈ 0.84 Mbps
```

### 3.5 缓存估算

```
遵循 80/20 法则：20%的短链贡献80%的流量
每日读请求：10亿次
需要缓存的热点数据：10,000,000 × 20% = 200万条
缓存大小：2,000,000 × 300 bytes ≈ 600 MB

结论：一台Redis实例即可满足缓存需求
```

---

## 四、短码生成方案

短码生成是短链服务的核心技术难点。一个好的短码需要满足：唯一性、不可预测性、长度短。

### 4.1 短码长度分析

```
使用 Base62 编码（a-z, A-Z, 0-9）：
  - 6位短码：62^6 = 568亿种组合
  - 7位短码：62^7 = 3.5万亿种组合

5年总数据量 = 182.5亿条
6位短码足够使用，但为了安全余量，选择7位短码。
```

### 4.2 方案一：哈希截取法

```
算法流程：
1. 对长URL计算哈希值（MD5 / SHA-256）
2. 将哈希值转换为Base62编码
3. 截取前7位作为短码
4. 检查是否冲突，冲突则追加随机字符重新哈希

示例：
  long_url = "https://www.example.com/path"
  md5_hash = "e99a18c428cb38d5f260853678922e03"
  base62   = "aB3kF9x..."
  short_code = "aB3kF9x"

优点：
  - 相同的长URL生成相同的短码（天然去重）
  - 实现简单

缺点：
  - 哈希冲突需要处理
  - 冲突检查需要查询数据库，影响性能
  - 冲突概率随数据量增大而增加（生日悖论）
```

### 4.3 方案二：自增ID + Base62 编码

```
算法流程：
1. 使用全局自增ID生成器生成唯一ID
2. 将ID转换为Base62编码作为短码

示例：
  id = 123456789
  base62_encode(123456789) = "8M0kX"

优点：
  - 天然唯一，无冲突
  - 性能高，无需冲突检查
  - 实现简单

缺点：
  - 短码可预测（安全性差）
  - 依赖全局ID生成器（单点问题）
  - 相同长URL会生成不同短码

改进方案：
  - ID生成器使用分布式方案（如Snowflake）
  - 对ID进行位运算混淆，增加不可预测性
```

#### Base62 编码实现

```python
CHARSET = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

def base62_encode(num: int) -> str:
    """将十进制数转换为Base62编码"""
    if num == 0:
        return CHARSET[0]

    result = []
    while num > 0:
        result.append(CHARSET[num % 62])
        num //= 62

    return ''.join(reversed(result))

def base62_decode(s: str) -> int:
    """将Base62编码转换为十进制数"""
    num = 0
    for char in s:
        num = num * 62 + CHARSET.index(char)
    return num
```

### 4.4 方案三：预生成短码池

```
算法流程：
1. 离线批量预生成大量唯一短码，存入数据库
2. 创建短链时，从短码池中取出一个未使用的短码
3. 短码池低于阈值时，触发异步补充

实现方式：
  - 使用一张 short_code_pool 表
  - 字段：short_code, is_used, assigned_at
  - 每次取出一批（如1000个）缓存到内存中

优点：
  - 短码完全随机，不可预测
  - 创建短链时无需计算，性能极高
  - 天然唯一

缺点：
  - 需要预生成和维护短码池
  - 短码池耗尽时需要等待补充
  - 存储开销较大
```

### 4.5 方案四：雪花算法（Snowflake）

```
结构（64位）：
┌─────────┬──────────┬────────────┬──────────────┐
│ 1位符号  │ 41位时间戳 │ 10位机器ID  │ 12位序列号    │
└─────────┴──────────┴────────────┴──────────────┘

特点：
  - 全局唯一
  - 趋势递增
  - 高性能（单机每秒可生成400万个ID）
  - 不依赖数据库

将生成的ID进行Base62编码即可得到短码。

优点：
  - 分布式环境下天然唯一
  - 高性能
  - 无需中心化的ID生成器

缺点：
  - 依赖机器时钟（时钟回拨问题）
  - 生成的ID较长，Base62编码后约11位
```

### 4.6 方案对比与选择

```
方案          唯一性   可预测性   性能    复杂度   推荐场景
──────────────────────────────────────────────────────────
哈希截取       需去重   低        中      低      小规模系统
自增ID+Base62  天然唯一 高(不安全) 高      中      内部系统
预生成短码池   天然唯一 低        极高    中      大规模系统
雪花算法       天然唯一 中        极高    中      分布式系统

推荐方案：自增ID + Base62 + 位运算混淆
  兼顾唯一性、性能和安全性
```

---

## 五、数据库设计与选型

### 5.1 数据表设计

```sql
-- 短链映射表
CREATE TABLE url_mapping (
    id          BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    short_code  VARCHAR(10)  NOT NULL,
    long_url    VARCHAR(2048) NOT NULL,
    user_id     BIGINT UNSIGNED DEFAULT NULL,
    created_at  DATETIME     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    expire_at   DATETIME     DEFAULT NULL,
    click_count BIGINT UNSIGNED DEFAULT 0,

    UNIQUE KEY uk_short_code (short_code),
    KEY idx_user_id (user_id),
    KEY idx_expire_at (expire_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 访问日志表（用于统计分析）
CREATE TABLE click_log (
    id          BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    short_code  VARCHAR(10)  NOT NULL,
    client_ip   VARCHAR(45)  NOT NULL,
    user_agent  VARCHAR(512) DEFAULT NULL,
    referer     VARCHAR(2048) DEFAULT NULL,
    country     VARCHAR(10)  DEFAULT NULL,
    created_at  DATETIME     NOT NULL DEFAULT CURRENT_TIMESTAMP,

    KEY idx_short_code_time (short_code, created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 5.2 数据库选型

```
主存储：MySQL
  - 短链映射关系是典型的结构化数据
  - 需要唯一性约束保证短码不重复
  - 数据量在TB级别，MySQL可以胜任
  - 通过分库分表支持水平扩展

分库分表策略：
  - 分片键：short_code
  - 分片方式：short_code 哈希取模
  - 分片数量：初始16个分片，后续可扩展
  - 每个分片约 350 GB（5.5 TB / 16）

访问日志：
  - 数据量巨大，写入频繁
  - 可选方案：
    a) Kafka + ClickHouse（推荐）：实时写入Kafka，异步消费到ClickHouse
    b) HBase：适合海量数据的顺序写入
    c) Elasticsearch：支持灵活的统计查询
```

---

## 六、缓存策略

### 6.1 缓存架构

```
请求流程：
  用户请求 → Nginx → 应用服务 → Redis缓存 → MySQL数据库

缓存读取流程（Cache-Aside模式）：
  1. 先查Redis缓存
  2. 缓存命中 → 直接返回长URL
  3. 缓存未命中 → 查询MySQL
  4. MySQL查到 → 写入Redis缓存，返回长URL
  5. MySQL未查到 → 返回404
```

### 6.2 缓存数据结构

```
Redis数据结构：
  Key:   sc:{short_code}
  Value: {long_url}
  TTL:   24小时（热点数据自动续期）

示例：
  SET sc:aB3kF9x "https://www.example.com/path" EX 86400
```

### 6.3 缓存策略细节

```
1. 热点数据缓存：
   - 新创建的短链立即写入缓存
   - 被访问的短链自动续期TTL
   - 冷数据自然过期淘汰

2. 缓存穿透防护：
   - 对不存在的短码，缓存空值（TTL=5分钟）
   - 使用布隆过滤器（Bloom Filter）前置过滤

3. 缓存击穿防护：
   - 热点短码使用互斥锁（Redis SETNX）
   - 或使用逻辑过期策略

4. 缓存雪崩防护：
   - TTL加随机偏移量，避免大量缓存同时过期
   - Redis集群部署，避免单点故障
```

### 6.4 布隆过滤器

```
作用：快速判断一个短码是否存在，过滤无效请求

实现：
  - 使用Redis的Bloom Filter模块
  - 或使用Guava BloomFilter（Java）

配置：
  - 预期元素数量：200亿
  - 误判率：0.01%
  - 内存占用：约 24 GB

流程：
  1. 创建短链时，将short_code加入布隆过滤器
  2. 查询时，先检查布隆过滤器
  3. 不存在 → 直接返回404（100%准确）
  4. 存在 → 继续查缓存和数据库（可能误判）
```

---

## 七、重定向：301 vs 302

### 7.1 两种重定向的区别

```
301 Moved Permanently（永久重定向）：
  - 浏览器会缓存重定向结果
  - 下次访问同一短链，浏览器直接跳转，不经过服务器
  - 减少服务器压力
  - 但无法统计访问次数

302 Found（临时重定向）：
  - 浏览器不缓存重定向结果
  - 每次访问都经过服务器
  - 可以统计每次访问
  - 服务器压力较大
```

### 7.2 选择建议

```
推荐使用 302 临时重定向：
  1. 可以准确统计访问次数和来源
  2. 可以随时修改目标URL
  3. 可以实现A/B测试（不同用户跳转到不同页面）
  4. 可以在跳转前做安全检查（恶意URL检测）

如果不需要统计功能，可以使用 301：
  1. 减少服务器压力
  2. 用户体验更快（浏览器直接跳转）
```

---

## 八、高可用与扩展方案

### 8.1 服务层高可用

```
                    ┌─────────────┐
                    │   DNS/CDN   │
                    └──────┬──────┘
                           │
                    ┌──────▼──────┐
                    │  负载均衡器   │
                    │  (Nginx/ALB) │
                    └──────┬──────┘
                           │
              ┌────────────┼────────────┐
              │            │            │
        ┌─────▼─────┐ ┌───▼─────┐ ┌───▼─────┐
        │ App Server │ │ App Srv │ │ App Srv │
        │  (无状态)   │ │ (无状态) │ │ (无状态) │
        └─────┬─────┘ └───┬─────┘ └───┬─────┘
              │            │            │
              └────────────┼────────────┘
                           │
              ┌────────────┼────────────┐
              │            │            │
        ┌─────▼─────┐ ┌───▼─────┐ ┌───▼─────┐
        │   Redis    │ │  Redis  │ │  Redis  │
        │  Cluster   │ │ Cluster │ │ Cluster │
        └─────┬─────┘ └───┬─────┘ └───┬─────┘
              │            │            │
              └────────────┼────────────┘
                           │
              ┌────────────┼────────────┐
              │            │            │
        ┌─────▼─────┐ ┌───▼─────┐ ┌───▼─────┐
        │  MySQL     │ │  MySQL  │ │  MySQL  │
        │  主库      │ │  从库1  │ │  从库2  │
        └───────────┘ └─────────┘ └─────────┘

关键设计：
  - 应用服务器无状态，可水平扩展
  - 负载均衡器做健康检查，自动摘除故障节点
  - Redis Cluster 提供缓存高可用
  - MySQL 主从复制，读写分离
```

### 8.2 数据层高可用

```
MySQL高可用方案：
  - 主从复制 + 半同步复制
  - MHA（Master High Availability）自动故障转移
  - 或使用云数据库（如 RDS Multi-AZ）

Redis高可用方案：
  - Redis Sentinel（哨兵模式）
  - Redis Cluster（集群模式，推荐）
  - 每个主节点至少一个从节点

数据备份：
  - MySQL：每日全量备份 + binlog增量备份
  - Redis：RDB快照 + AOF日志
```

### 8.3 多地域部署

```
对于全球化的短链服务：
  1. 使用GeoDNS将用户路由到最近的数据中心
  2. 每个数据中心部署完整的服务栈
  3. 数据库使用跨地域复制
  4. 短码生成使用不同的ID范围，避免冲突

示例：
  - 北美数据中心：ID范围 [0, 10亿)
  - 欧洲数据中心：ID范围 [10亿, 20亿)
  - 亚太数据中心：ID范围 [20亿, 30亿)
```

---

## 九、完整架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                         客户端层                                 │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐                      │
│  │ 浏览器    │  │ 移动App  │  │ 第三方API │                      │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘                      │
└───────┼──────────────┼─────────────┼────────────────────────────┘
        │              │             │
        ▼              ▼             ▼
┌─────────────────────────────────────────────────────────────────┐
│                        接入层                                    │
│  ┌──────────────────────────────────────┐                       │
│  │           CDN / DNS                   │                       │
│  └──────────────────┬───────────────────┘                       │
│                     ▼                                            │
│  ┌──────────────────────────────────────┐                       │
│  │      负载均衡 (Nginx / ALB)           │                       │
│  │      - SSL终止                        │                       │
│  │      - 限流                           │                       │
│  │      - 健康检查                        │                       │
│  └──────────────────┬───────────────────┘                       │
└─────────────────────┼───────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                       服务层                                     │
│                                                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │ 短链创建服务  │  │ 短链跳转服务  │  │ 统计分析服务  │             │
│  │             │  │             │  │             │             │
│  │ - 短码生成   │  │ - 缓存查询   │  │ - 点击统计   │             │
│  │ - 去重检查   │  │ - 302重定向  │  │ - 报表生成   │             │
│  │ - 数据持久化 │  │ - 过期检查   │  │ - 实时分析   │             │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘             │
└─────────┼────────────────┼────────────────┼─────────────────────┘
          │                │                │
          ▼                ▼                ▼
┌─────────────────────────────────────────────────────────────────┐
│                       数据层                                     │
│                                                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ Redis Cluster │  │ MySQL Cluster │  │  ClickHouse  │          │
│  │              │  │              │  │              │          │
│  │ - 短链缓存    │  │ - 短链映射    │  │ - 访问日志    │          │
│  │ - 布隆过滤器  │  │ - 用户数据    │  │ - 统计报表    │          │
│  │ - 计数器      │  │ - 分库分表    │  │              │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
│                                                                 │
│  ┌──────────────┐                                               │
│  │    Kafka     │                                               │
│  │              │                                               │
│  │ - 点击事件    │                                               │
│  │ - 异步处理    │                                               │
│  └──────────────┘                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 核心请求流程

```
创建短链流程：
  1. 客户端 POST /api/v1/shorten
  2. 负载均衡器转发到短链创建服务
  3. 生成唯一短码（自增ID + Base62）
  4. 写入MySQL（短链映射表）
  5. 写入Redis缓存
  6. 将短码加入布隆过滤器
  7. 返回短URL给客户端

短链跳转流程：
  1. 客户端 GET /{short_code}
  2. 负载均衡器转发到短链跳转服务
  3. 布隆过滤器检查短码是否存在
  4. 不存在 → 返回404
  5. 存在 → 查询Redis缓存
  6. 缓存命中 → 返回302重定向
  7. 缓存未命中 → 查询MySQL
  8. MySQL查到 → 写入缓存，返回302重定向
  9. 异步发送点击事件到Kafka
  10. ClickHouse消费Kafka事件，更新统计数据
```

---

## 十、进阶优化

### 10.1 防刷与安全

```
1. 接口限流：每个IP/用户每分钟最多创建N个短链
2. 恶意URL检测：接入安全扫描服务，检测钓鱼/恶意URL
3. 验证码：高频创建时触发验证码
4. 短码混淆：避免短码被遍历
5. HTTPS：全链路HTTPS加密
```

### 10.2 过期清理

```
1. 惰性删除：访问时检查是否过期，过期则删除并返回404
2. 定时清理：后台定时任务扫描过期数据并删除
3. 分区表：按月分区，过期数据直接删除分区
```

### 10.3 监控告警

```
关键监控指标：
  - 短链创建QPS和成功率
  - 短链跳转QPS和延迟（P50/P99）
  - 缓存命中率（目标 > 95%）
  - 数据库连接数和慢查询
  - Redis内存使用率
  - 错误率和4xx/5xx比例
```

---

## 十一、总结

短链服务虽然功能简单，但涵盖了系统设计的核心要素：

```
1. 短码生成 → 分布式ID生成问题
2. 缓存策略 → 缓存穿透/击穿/雪崩问题
3. 数据库设计 → 分库分表问题
4. 高可用 → 冗余部署、故障转移问题
5. 性能优化 → 读写分离、异步处理问题
```

这些技术点在其他系统设计中同样适用，掌握短链服务的设计方法，可以举一反三地应用到更复杂的系统中。
